<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>离散数学 - 课堂笔记 - 佛得角大海豹的博客</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="佛得角大海豹的博客">
    <meta property="og:title" content="离散数学 - 课堂笔记"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="佛得角大海豹的博客" type="application/atom+xml">
</head>

  <body>
    <header>
    <div class="head-title">
        <h4>佛得角大海豹的博客</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="category-link" href="/categories/%E5%B0%8F%E8%AF%B4/">小说</a><a class="category-link" href="/categories/%E8%AF%97%E6%AD%8C/">诗歌</a><a class="category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>离散数学 - 课堂笔记</h2>
            <div class="post-meta">
                <time class="date">2020.08.25</time>
            
                <span class="category"><a class="category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <blockquote>这篇文章上次修改于 696 天前，可能其部分内容已经发生变化，如有疑问可询问作者。</blockquote>
        
            <h1 id="离散数学">离散数学</h1>
<blockquote>
<p>参考书：《离散数学及其应用》（第三版）</p>
</blockquote>
<h4 id="离散量">离散量</h4>
<p><strong>离散量</strong>：从一种程度开始，只要经过有限多种程度的逐次更替就能变化到另一种程度。</p>
<h2 id="一集合论">一、集合论</h2>
<h3 id="什么是集合">1.1 什么是集合</h3>
<ul>
<li><p><strong>集合</strong>：一组对象</p>
<p><strong>集合</strong>是由指定范围内的满足给定条件的所有对象聚集在一起构成，每一个对象成为这个集合的<strong>元素</strong>。</p>
<p><strong>ZFC公理化集合论</strong>：外延公理 + 空集存在公理 +
无序对公理 + 并集公理 + 幂集公理 + 无穷公理 + 替换公理 + 正则公理 +
选择公理</p>
<p>用带或不带下标的<strong>大写</strong>英文字母表示<strong>集合</strong>：<span
class="math inline">\(A, B, C, \dots, A_1, B_1, C_1, \dots\)</span></p>
<p>用带或不带下标的<strong>小写</strong>英文字母表示<strong>元素</strong>：<span
class="math inline">\(a, b, c, \dots, a_1, b_1, c_1, \dots\)</span></p>
<p>若<span class="math inline">\(a\)</span>是<span
class="math inline">\(A\)</span>中元素，记作<span
class="math inline">\(a \in A\)</span>，否则记作<span
class="math inline">\(a \notin A\)</span>。</p></li>
<li><p><strong>表示方法</strong></p>
<p><strong>枚举法</strong>：<span class="math inline">\(A = \{a, b, c,
d\}\)</span> 或 <span class="math inline">\(B = \{1, 2, 3,
\dots\}\)</span></p>
<p><strong>叙述法</strong>：<span
class="math inline">\(A=\{x|x是英文字母中的元音字母\}\)</span> 或 <span
class="math inline">\(B = \{x|x \in Z, x &lt; 10\}\)</span></p>
<p><strong>文氏图</strong>：图解方法。一般使用平面上的方形或圆形表示一个集合，用平面上的一个点表示集合的元素。（即<strong>韦恩图</strong>。）</p>
<figure>
<img src="https://s2.ax1x.com/2020/02/26/3U0YAU.png" title="文氏图"
alt="文氏图" />
<figcaption aria-hidden="true">文氏图</figcaption>
</figure></li>
<li><p><strong>基数</strong></p>
<p>集合A中的元素个数称为集合的<strong>基数</strong>，记作<span
class="math inline">\(|A|\)</span>。</p>
<p>若一个集合的基数是有限的，则该集合称为<strong>有限集</strong>。</p>
<p>若一个集合的基数是无限的，则该集合称为<strong>无限集</strong>。</p>
<p><span class="math display">\[A = \{a, b, c\}, 则|A| = 3\]</span>
<span class="math display">\[B = \{a, \{b, c\}\}, 则 |B| =
2\]</span></p></li>
</ul>
<h3 id="特殊集合和集合间关系">1.2 特殊集合和集合间关系</h3>
<ul>
<li><p><strong>空集</strong></p>
<p>不含任何元素的集合叫做<strong>空集</strong>，记作<span
class="math inline">\(\varnothing\)</span>。</p>
<p>空集可以符号化为<span class="math inline">\(\varnothing = \{x|\, x
\not= x\}\)</span>。</p>
<p>空集是<strong>绝对唯一</strong>的。</p></li>
<li><p><strong>全集</strong></p>
<p>针对一个具体范围，我们考虑的所有对象的集合叫做<strong>全集</strong>，记作<span
class="math inline">\(U\)</span>或<span
class="math inline">\(E\)</span>。</p>
<p>在文氏图中一般使用<strong>方形</strong>表示全集。</p>
<p>全集是<strong>相对唯一</strong>的。</p></li>
<li><p>集合的相等关系</p>
<ul>
<li><p>元素的基本特性</p>
<ul>
<li>集合中的元素是<strong>无序</strong>的。</li>
<li>集合中的元素是<strong>不同</strong>的。</li>
</ul></li>
<li><p>外延性原理</p>
<p>两个集合<span class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span><strong>相等</strong>，当且仅当它们的<strong>元素完全相同</strong>，记为<span
class="math inline">\(A = B\)</span>，否则<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span><strong>不相等</strong>，记为<span
class="math inline">\(A \not= B\)</span>。</p></li>
</ul></li>
<li><p><strong>子集</strong>和<strong>真子集</strong></p>
<p>设<span class="math inline">\(A, B\)</span>是任意两个集合。</p>
<ul>
<li>如果<span class="math inline">\(B\)</span>的每个元素都是<span
class="math inline">\(A\)</span>中的元素，则称<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的子集，也称作<span
class="math inline">\(B\)</span>被<span
class="math inline">\(A\)</span>包含或<span
class="math inline">\(A\)</span>包含<span
class="math inline">\(B\)</span>，记作<span class="math inline">\(B
\subseteq A\)</span>，否则记作<span class="math inline">\(B \nsubseteq
A\)</span>。</li>
<li>如果<span class="math inline">\(B \subseteq A\)</span>并且<span
class="math inline">\(A \not= B\)</span>，则称<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的<strong>真子集</strong>，也称作<span
class="math inline">\(B\)</span>被<span
class="math inline">\(A\)</span><strong>真包含</strong>或<span
class="math inline">\(A\)</span><strong>真包含</strong><span
class="math inline">\(B\)</span>，记作<span class="math inline">\(B
\subset A\)</span>，否则记作<span class="math inline">\(B \not\subset
A\)</span>。</li>
</ul>
<p>“<span
class="math inline">\(\subseteq\)</span>”关系的数学语言描述是：<span
class="math inline">\(B \subseteq A \Leftrightarrow \forall x, \text{若}
x \in B, \text{则} x \in A\)</span>。</p>
<figure>
<img src="https://s2.ax1x.com/2020/02/28/3BkCtS.png"
alt="子集和真子集" />
<figcaption aria-hidden="true">子集和真子集</figcaption>
</figure>
<p>由子集定义可有</p>
<p><span class="math display">\[
  \varnothing \subseteq A
  \]</span></p>
<p><span class="math display">\[
  A \subseteq A
  \]</span></p></li>
<li><p>证明集合相等</p>
<p>设<span class="math inline">\(A, B\)</span>为任意两个集合，则</p>
<p><span class="math display">\[
  A = B \Leftrightarrow A \subseteq B 且 B \subseteq A
  \]</span></p></li>
<li><p><span class="math inline">\(n\)</span>元集的子集</p>
<p>对于任意<span class="math inline">\(n\)</span>元集合<span
class="math inline">\(A\)</span>，它的<span
class="math inline">\(m\)</span>元<span class="math inline">\((0 \leq m
\leq n)\)</span>子集个数为<span
class="math inline">\(C_n^m\)</span>个，所以不同的子集个数为<span
class="math inline">\(C_n^0 + C_n^1 + \dots + C_n^n =
2^n\)</span>。</p></li>
<li><p><strong>幂集</strong></p>
<p>设<span class="math inline">\(A\)</span>为任意集合，把<span
class="math inline">\(A\)</span>的所有不同子集构成的集合叫做A的<strong>幂集</strong>，也叫<strong>集族</strong>或<strong>集合的集合</strong>，记作<span
class="math inline">\(P(A)\)</span>，即</p>
<p><span class="math display">\[
  P(A) = \{x|\, x \subseteq A \}
  \]</span></p></li>
</ul>
<h3 id="集合的基本运算">1.3 集合的基本运算</h3>
<ul>
<li><p><strong>并集</strong></p>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，则集合<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>并集</strong>定义为</p>
<p><span class="math display">\[
  A \cup B = \{x | x \in A 或 x \in B\}
  \]</span></p></li>
<li><p><strong>交集</strong></p>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，则集合<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>交集</strong>定义为</p>
<p><span class="math display">\[
  A \cap B = \{x | x \in A 且 x \in B\}
  \]</span></p></li>
<li><p><strong>补集</strong></p>
<p>设<span class="math inline">\(U\)</span>是全集，则集合<span
class="math inline">\(A\)</span>的<strong>补集</strong>定义为</p>
<p><span class="math display">\[
  \overline A = \{x | x \notin A\}
  \]</span></p></li>
<li><p><strong>差集</strong></p>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，则集合<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>差集</strong>定义为</p>
<p><span class="math display">\[
  A - B = \{x | x \in A 且 x \notin B\}
  \]</span></p></li>
<li><p><strong>对称差集</strong></p>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，则集合<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>对称差集</strong>定义为</p>
<p><span class="math display">\[
  \begin{align}
  A \oplus B &amp;= \{x |( x \in A 且 x \notin B ) 或 (x \notin A 且 x
\in B)\} \\
  &amp;= (A - B) \cup (B - A)
  \end{align}
  \]</span></p></li>
<li><p>并集和交集的扩展</p>
<p>设<span class="math inline">\(A_1, A_2, \dots,
A_n\)</span>是任意<span
class="math inline">\(n\)</span>个集合，则这<span
class="math inline">\(n\)</span>个集合的<strong>并集</strong>是包含那些至少是这组集合中一个集合成员的元素的集合，即</p>
<p><span class="math display">\[
  \bigcup_{i=1}^n A_i = A_1 \cup A_2 \cup \dots \cup A_n = \{x | x \in
A_1 或 x \in A_2 或 \dots 或 x \in A_n\}
  \]</span></p>
<p>设<span class="math inline">\(A_1, A_2, \dots,
A_n\)</span>是任意<span
class="math inline">\(n\)</span>个集合，则这<span
class="math inline">\(n\)</span>个集合的<strong>交集</strong>是包含那些属于这组聚合中所有集合成员的元素的集合，即</p>
<p><span class="math display">\[
  \bigcap_{i=1}^n A_i = A_1 \cap A_2 \cap \dots \cap A_n = \{x | x \in
A_1 且 x \in A_2 且 \dots 且 x \in A_n\}
  \]</span></p></li>
</ul>
<h3 id="集合的运算定律">1.4 集合的运算定律</h3>
<h4 id="集合运算的基本等式">集合运算的基本等式</h4>
<p>设<span class="math inline">\(U\)</span>为全集，<span
class="math inline">\(A, B, C\)</span>为任意集合。 <span
class="math display">\[
A \cup A = A,\quad A \cap A = A \tag{幂等律}
\]</span></p>
<p><span class="math display">\[
A \cup B = B \cup A,\quad A \cap B = B \cap A \tag{交换律}
\]</span></p>
<p><span class="math display">\[
(A \cup B) \cup C = A \cup (B \cup C), \\ (A \cap B) \cap C = A \cap (B
\cap C) \tag{结合律}
\]</span></p>
<p><span class="math display">\[
A \cup \varnothing = A, \quad A \cap U = A \tag{同一律}
\]</span></p>
<p><span class="math display">\[
A \cap \varnothing = \varnothing, \quad A \cup U = U \tag{零律}
\]</span></p>
<p><span class="math display">\[
(A \cap B) \cup C = (A \cup C) \cap (B \cup C), \\
(A \cup B) \cap C = (A \cap C) \cup (B \cap C) \tag{分配律}
\]</span></p>
<p><span class="math display">\[
A \cap (A \cup B) = A, \quad A \cup (A \cap B) = A \tag{吸收律}
\]</span></p>
<p><span class="math display">\[
\overline{A} \cap A = \varnothing, \quad \overline{A} \cup A = U
\tag{矛盾律和排中律}
\]</span></p>
<p><span class="math display">\[
\overline{\overline{A}} = A \tag{双重否定律}
\]</span></p>
<p><span class="math display">\[
\overline{A \cup B} = \overline{A} \cap \overline{B}, \quad \overline{A
\cap B} = \overline{A} \cup \overline{B} \tag{德·摩根律}
\]</span></p>
<h4 id="集合相等的证明">集合相等的证明</h4>
<p>如需证明集合A和B相等，则证明两个集合的相互包含关系，即 <span
class="math display">\[
A = B \Leftrightarrow A \subseteq B 并且 B \subseteq A
\]</span></p>
<blockquote>
<p>或者尝试反证：如果<span class="math inline">\(\exist x \in A且x
\not\in B\)</span>，以及对称的情况，得出矛盾；</p>
<p>或者尝试改变A的写法，使其包含给定条件，然后代入条件，得出B。</p>
</blockquote>
<h3 id="可数集合与不可数集合">1.5 可数集合与不可数集合</h3>
<p><span class="math inline">\(\aleph_0\)</span>：可数集合</p>
<p><span class="math inline">\(\aleph_1\)</span>：不可数集合</p>
<h4 id="自然数集的定义">自然数集的定义</h4>
<p><strong>皮亚诺公理</strong></p>
<ul>
<li><span class="math inline">\(0\)</span>是自然数；</li>
<li>每个自然数<span
class="math inline">\(n\)</span>都有一个后继，这个后继也是一个自然数，记为<span
class="math inline">\(S(n)\)</span>；</li>
<li>两个自然数相等，当且仅当它们有相同的后继，即：<span
class="math inline">\(m = n\)</span>，当且仅当<span
class="math inline">\(S(m) = S(n)\)</span>；</li>
<li>没有任何自然数的后继是0；</li>
<li>（<strong>归纳公理</strong>）若<span
class="math inline">\(\varphi\)</span>是关于一个自然数的预测，如果：<span
class="math inline">\(\varphi (0)\)</span>为真，且当<span
class="math inline">\(\varphi (n)\)</span>为真，则有<span
class="math inline">\(\varphi(S(n))\)</span>为真，则<span
class="math inline">\(\varphi (n)\)</span>对任意自然数<span
class="math inline">\(n\)</span>都成立。</li>
</ul>
<p><strong>冯·诺依曼的自然数定义</strong></p>
<ul>
<li><span class="math inline">\(\varnothing \in N\)</span></li>
<li>若<span class="math inline">\(n \in N\)</span>，则<span
class="math inline">\(n&#39; \equiv n \cup \{n\} \in N\)</span></li>
</ul>
<p>从而，这个<strong>集合序列的基数</strong>就可以来定义自然数：</p>
<ul>
<li><span class="math inline">\(0 \equiv |\varnothing|\)</span></li>
<li><span class="math inline">\(1 \equiv |\varnothing \cup
\{\varnothing\}| = |\{\varnothing\}|\)</span></li>
<li><span class="math inline">\(2 \equiv |\{\varnothing\} \cup
\{\{\varnothing\}\}| = |\{\varnothing, \{\varnothing\}\}|\)</span></li>
</ul>
<h4 id="如何比较集合的大小">如何比较集合的大小</h4>
<p>对于无限集合，通过判断两个无限集合之间是否存在一一对应关系来判断大小。</p>
<p><strong>等势</strong>：设<span class="math inline">\(A,
B\)</span>为两个集合，若在<span class="math inline">\(A,
B\)</span>之间存在一种一一对应的关系： <span class="math display">\[
\Psi: A \to B
\]</span> 则称<span class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>是<strong>等势</strong>的，记作<span
class="math inline">\(A \sim B\)</span>。</p>
<blockquote>
<p>若<span class="math inline">\(A = B\)</span>，则<span
class="math inline">\(A \sim B\)</span>。反之不成立。</p>
</blockquote>
<h4 id="可数集合">可数集合</h4>
<p>凡与自然数集合<span
class="math inline">\(N\)</span>等势的集合，称为<strong>可数集合</strong>，<strong>可数集合的基数</strong>记为<span
class="math inline">\(\aleph_0\)</span>。</p>
<h4 id="不可数集合">不可数集合</h4>
<p><strong>开区间<span class="math inline">\((0,
1)\)</span></strong>称为不可数集合。</p>
<p>凡与开区间<span class="math inline">\((0,
1)\)</span>等势的集合，称为<strong>不可数集合</strong>，<strong>不可数集合的基数</strong>记为<span
class="math inline">\(\aleph_1\)</span>。</p>
<h2 id="第二章-计数问题">第二章 计数问题</h2>
<h3 id="加法原理和乘法原理">2.1 加法原理和乘法原理</h3>
<p><strong>乘法原理</strong>：如果一些工作需要<span
class="math inline">\(t\)</span>步完成，第<span
class="math inline">\(i\)</span>步有<span
class="math inline">\(n_i\)</span>种不同的选择，则完成这项工作所有可能的选择种数为
<span class="math display">\[
n_1 \times n_2 \times \dots n_t
\]</span> <strong>加法原理</strong>：假定<span
class="math inline">\(X_1, X_2, \dots, X_t\)</span>均为集合，第<span
class="math inline">\(i\)</span>个集合<span
class="math inline">\(X_i\)</span>有<span
class="math inline">\(n_i\)</span>个元素。如<span
class="math inline">\(\{X_1, X_2, \dots,
X_t\}\)</span>为两两不相交的集合，则可以从<span
class="math inline">\(X_1, X_2, \dots, X_t\)</span>中选出的元素总数为
<span class="math display">\[
n_1 + n_2 + \dots + n_t
\]</span> 即集合<span class="math inline">\(X_1 \cup X_2 \cup \dots \cup
X_t\)</span>的元素数目。</p>
<h3 id="排列与组合">2.2 排列与组合</h3>
<p><strong>排列</strong>：从含<span
class="math inline">\(n\)</span>各不同元素的集合<span
class="math inline">\(S\)</span>种有序选取的<span
class="math inline">\(r\)</span>个元素叫做<span
class="math inline">\(S\)</span>的一个<strong><span
class="math inline">\(r\)</span>-排列</strong>。不同的排列总数记为<span
class="math inline">\(P(n, r)\)</span>。如果<span
class="math inline">\(r =
n\)</span>，则称这个排列为S的一个<strong>全排列</strong>，简称为<span
class="math inline">\(S\)</span>的排列。 <span class="math display">\[
P(n, r) = n(n-1)\dots(n-(r-1))
\]</span> 推论：<span
class="math inline">\(n\)</span>个不同元素的排列共有<span
class="math inline">\(n!\)</span>种。</p>
<p>环形排列：含<span
class="math inline">\(n\)</span>个不同元素的集合的环形<span
class="math inline">\(r\)</span>-排列数<span
class="math inline">\(P_c(n, r)\)</span>是 <span class="math display">\[
P_c(n, r) = \frac{P(n, r)}{r}
\]</span> <strong>组合</strong>：从含有<span
class="math inline">\(n\)</span>个不同元素的集合<span
class="math inline">\(S\)</span>中<strong>无序选取</strong>的<span
class="math inline">\(r\)</span>个元素叫做<span
class="math inline">\(S\)</span>的一个<span
class="math inline">\(r\)</span> -组合，不同的组合总数记为<span
class="math inline">\(C(n, r)\)</span>。规定<span
class="math inline">\(C(n, 0) = 1\)</span>。 <span
class="math display">\[
C(n, r) = \frac{n!}{r!(n-r)!}
\]</span></p>
<h3 id="容斥原理和鸽笼原理">2.3 容斥原理和鸽笼原理</h3>
<p><strong>容斥原理</strong>：设<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>是任意有限集合，有 <span
class="math display">\[
|A \cup B| = |A| + |B| - |A \cap B|
\]</span> 设<span class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span>和<span
class="math inline">\(C\)</span>是任意有限集合，有 <span
class="math display">\[
|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap
C| + |A \cap B \cap C|
\]</span> <strong>鸽笼原理</strong>：若有<span
class="math inline">\(n+1\)</span>只鸽子住进<span
class="math inline">\(n\)</span>个鸽笼，则（存在性）有一个鸽笼至少住进<span
class="math inline">\(2\)</span>只鸽子。</p>
<h2 id="第三章-命题逻辑">第三章 命题逻辑</h2>
<h3 id="什么是命题">3.1 什么是命题</h3>
<p>命题是推理的前提和结论。命题是推理的基本单位。</p>
<p><strong>命题</strong>：具有确切真值的陈述句。该命题可以取一个“值”，称为<strong>真值</strong>。真值只有“真”和“假”两种，分别用“T”（或“1”）和“F”（或“0”）表示。</p>
<p>一切没有判断内容的句子，如命令句（祈使句）、感叹句、疑问句、二义性的陈述句等都不能作为命题。</p>
<blockquote>
<p><em>我们无法判断真假的句子</em>和<em>句子本身是否有真假</em>是两回事。例如：“今天是晴天。”</p>
</blockquote>
<blockquote>
<p>命题带变量如<span class="math inline">\(x,
y\)</span>，但却不对变量作任何限制，因为变量可以取甚至不是数，导致了二义性，因此不是命题。例如：“<span
class="math inline">\(x+y&gt;0\)</span>”不是命题。</p>
</blockquote>
<ul>
<li><p><strong>原子命题（简单命题）</strong>：不能再分解为更为简单命题的命题。</p></li>
<li><p><strong>复合命题</strong>：可以分解为更为简单命题的命题。</p></li>
</ul>
<blockquote>
<p>约定：通常用大写的、带或不带下标的英文字母表示命题。</p>
</blockquote>
<h3 id="命题联结词">3.2 命题联结词</h3>
<h4 id="否定联结词">否定联结词</h4>
<p>设<span
class="math inline">\(P\)</span>是任意一个命题，复合命题“非<span
class="math inline">\(P\)</span>”或“<span
class="math inline">\(P\)</span>的否定”称为<span
class="math inline">\(P\)</span>的<strong>否定式</strong>，记作<span
class="math inline">\(\lnot P\)</span>，“<span
class="math inline">\(\lnot\)</span>”为<strong>否定联结词</strong>。<span
class="math inline">\(P\)</span>为真，当且仅当<span
class="math inline">\(\lnot P\)</span>为假。</p>
<h4 id="合取联结词">合取联结词</h4>
<p>设<span class="math inline">\(P\)</span>、<span
class="math inline">\(Q\)</span>是任意两个命题，复合命题“<span
class="math inline">\(P\)</span>并且<span
class="math inline">\(Q\)</span>”或“<span
class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>”称为<span
class="math inline">\(P\)</span>与<span
class="math inline">\(Q\)</span>的<strong>合取式</strong>，记作<span
class="math inline">\(P \land Q\)</span>，“<span
class="math inline">\(\land\)</span>”为<strong>合取联结词</strong>。<span
class="math inline">\(P \land Q\)</span>为真，当且仅当<span
class="math inline">\(P, Q\)</span>同为真。</p>
<ul>
<li>虽然……但是……</li>
</ul>
<h4 id="析取联结词">析取联结词</h4>
<p>设<span class="math inline">\(P\)</span>、<span
class="math inline">\(Q\)</span>是任意两个命题，复合命题“<span
class="math inline">\(P\)</span>或<span
class="math inline">\(Q\)</span>”称为<span
class="math inline">\(P\)</span>与<span
class="math inline">\(Q\)</span>的<strong>析取式</strong>，记作<span
class="math inline">\(P \lor Q\)</span>，“<span
class="math inline">\(\lor\)</span>”为<strong>析取联结词</strong>。<span
class="math inline">\(P \lor Q\)</span>为真，当且仅当<span
class="math inline">\(P, Q\)</span>至少一个为真。</p>
<p><strong>异或</strong>用单独的异或联结词<span
class="math inline">\(\oplus\)</span>或<span
class="math inline">\(\overline \lor\)</span>。</p>
<p><span class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>不能同时为真，称为<strong>不可兼或</strong>。</p>
<h4 id="蕴涵联结词">蕴涵联结词</h4>
<p>设<span class="math inline">\(P\)</span>、<span
class="math inline">\(Q\)</span>是任意两个命题，复合命题“如果<span
class="math inline">\(P\)</span>，则<span
class="math inline">\(Q\)</span>”称为<span
class="math inline">\(P\)</span>与<span
class="math inline">\(Q\)</span>的<strong>蕴涵式</strong>，记作<span
class="math inline">\(P \to Q\)</span>，“<span
class="math inline">\(\to\)</span>”为<strong>蕴涵联结词</strong>。<span
class="math inline">\(P \to Q\)</span>为假，当且仅当<span
class="math inline">\(P\)</span>为真且<span
class="math inline">\(Q\)</span>为假。一般把蕴涵式<span
class="math inline">\(P \to Q\)</span>中的<span
class="math inline">\(P\)</span>称为该蕴涵式的前件，<span
class="math inline">\(Q\)</span>称为蕴涵式的后件。</p>
<ul>
<li>如果<span class="math inline">\(P\)</span>，则<span
class="math inline">\(Q\)</span></li>
<li>因为<span class="math inline">\(P\)</span>，所以<span
class="math inline">\(Q\)</span></li>
<li>只要<span class="math inline">\(P\)</span>，就<span
class="math inline">\(Q\)</span></li>
<li><span class="math inline">\(P\)</span>，仅当<span
class="math inline">\(Q\)</span></li>
<li>只有<span class="math inline">\(Q\)</span>，才<span
class="math inline">\(P\)</span></li>
<li>除非<span class="math inline">\(Q\)</span>，才<span
class="math inline">\(P\)</span></li>
<li>除非<span class="math inline">\(Q\)</span>，否则<span
class="math inline">\(\lnot P\)</span></li>
</ul>
<p><strong>善意推定</strong>：当前件<span
class="math inline">\(P\)</span>为假时，不管<span
class="math inline">\(Q\)</span>的真假，<span class="math inline">\(P
\to Q\)</span>都为真。</p>
<p><strong>逆否命题</strong>：<span class="math inline">\(P \to Q \quad
\Leftrightarrow \quad \lnot Q \to \lnot P\)</span></p>
<h4 id="等价联结词">等价联结词</h4>
<p>设<span class="math inline">\(P\)</span>、<span
class="math inline">\(Q\)</span>是任意两个命题，复合命题“<span
class="math inline">\(P\)</span>，当且仅当<span
class="math inline">\(Q\)</span>”称为<span
class="math inline">\(P\)</span>与<span
class="math inline">\(Q\)</span>的<strong>等价式</strong>，记作<span
class="math inline">\(P \leftrightarrow Q\)</span>，“<span
class="math inline">\(\leftrightarrow\)</span>”为<strong>等价联结词</strong>（也称<strong>双条件联结词</strong>）。<span
class="math inline">\(P \leftrightarrow Q\)</span>为假，当且仅当<span
class="math inline">\(P, Q\)</span>同真假。</p>
<h3 id="命题符号化及其应用">3.3 命题符号化及其应用</h3>
<h4 id="命题联结词的真值表">命题联结词的真值表</h4>
<h4 id="命题联结词的优先级">命题联结词的优先级</h4>
<p>否定 &gt; 合取 &gt; 析取 &gt; 蕴涵 &gt; 等价</p>
<p><span class="math inline">\(\lnot &gt; \land &gt; \lor &gt; \to &gt;
\leftrightarrow\)</span></p>
<p>同级的联结词从左到右；括号提升为最高优先级。</p>
<h4 id="复合命题符号化">复合命题符号化</h4>
<blockquote>
<p><strong>例</strong>：</p>
<p><span class="math inline">\(P\)</span>：你陪伴我</p>
<p><span class="math inline">\(Q\)</span>：你代我叫车子</p>
<p><span class="math inline">\(R\)</span>：我将出去</p>
<p><em>除非</em>你陪伴我<em>或</em>代我叫车子，<em>否则</em>我将<em>不</em>出去。</p>
<p><span class="math inline">\(R \to P \lor Q\)</span> 或 <span
class="math inline">\(\lnot P \land \lnot Q \to \lnot R\)</span></p>
</blockquote>
<h4 id="命题联结词与开关电路">命题联结词与开关电路</h4>
<p>串联：<span class="math inline">\(P \land Q\)</span></p>
<p>并联：<span class="math inline">\(P \lor Q\)</span></p>
<p>断开：<span class="math inline">\(\lnot P\)</span></p>
<h4 id="命题联结词与逻辑电路">命题联结词与逻辑电路</h4>
<p>与门：<span class="math inline">\(P \land Q\)</span></p>
<p>或门：<span class="math inline">\(P \lor Q\)</span></p>
<p>非门：<span class="math inline">\(\lnot P\)</span></p>
<h4 id="命题联结词与网页检索">命题联结词与网页检索</h4>
<h4 id="命题联结词与位运算">命题联结词与位运算</h4>
<ul>
<li>按位与</li>
<li>按位或</li>
<li>按位取反</li>
</ul>
<h3 id="命题公式和真值表">3.4 命题公式和真值表</h3>
<h4 id="命题变元">命题变元</h4>
<p>一个特定的命题是一个<strong>常值命题</strong>，它要么具有值<span
class="math inline">\(T\)</span>（或1），要么具有值<span
class="math inline">\(F\)</span>（或0）。</p>
<p>一个任意的没有赋予具体内容的<strong>原子命题</strong>是一个变量命题，称为<strong>命题变量</strong>或<strong>命题变元</strong>。该命题变量无具体的真值，它的变域是集合<span
class="math inline">\(\{T, F\}\)</span>（或<span
class="math inline">\(\{0, 1\}\)</span>）。</p>
<p>一个复合命题的原子命题是命题变元时，该复合命题是<strong>命题公式</strong>。</p>
<h4 id="命题公式">命题公式</h4>
<p>命题演算的合式公式，又称<strong>命题公式</strong>，简称<strong>公式</strong>。</p>
<p><strong>生成规则</strong>：</p>
<ol type="1">
<li><p>命题变元本身是一个公式；</p></li>
<li><p>如<span class="math inline">\(G\)</span>是公式，则<span
class="math inline">\(\lnot G\)</span>也是公式；</p></li>
<li><p>如<span class="math inline">\(G, H\)</span>是公式，则<span
class="math inline">\(G \land H, G \or H, G \to H, G \leftrightarrow
H\)</span>也是公式；</p></li>
<li><p>仅由有限步使用1. 2. 3.
后所得到的包含命题变元、联结词和括号的符号串才是命题公式。</p></li>
</ol>
<p>如果公式<span class="math inline">\(G\)</span>含有<span
class="math inline">\(n\)</span>个命题变元<span
class="math inline">\(P_1, P_2, \dots, P_n\)</span>，可记为<span
class="math inline">\(G(P_1, P_2, \dots, P_n)\)</span>。</p>
<p>原子命题变元是最简单的合式公式，称为<strong>原子合式公式</strong>，简称<strong>原子公式</strong>。</p>
<p>命题公式没有真值，只有对其命题变元进行真值指派后，命题公式的真值才能确定。</p>
<p>整个公式的最外层括号可以省略；公式中不影响运算次序的括号也可以省略。</p>
<p>命题公式常用<strong>二元树</strong>的方式来表达。</p>
<figure>
<img src="https://s1.ax1x.com/2020/03/13/8nmndH.png" alt="二元树" />
<figcaption aria-hidden="true">二元树</figcaption>
</figure>
<h4 id="公式的解释">公式的解释</h4>
<p>设<span class="math inline">\(P_1, P_2, \dots,
P_n\)</span>是出现在公式G中的所有命题变元，指定<span
class="math inline">\(P_1, P_2, \dots,
P_n\)</span>一组真值，则这组真值称为<span
class="math inline">\(G\)</span>的一个<strong>解释</strong>，常记为<span
class="math inline">\(I\)</span>。</p>
<p>如果公式<span class="math inline">\(G\)</span>在解释<span
class="math inline">\(I\)</span>下真，则称<span
class="math inline">\(I\)</span><strong>满足</strong><span
class="math inline">\(G\)</span>，此时<span
class="math inline">\(I\)</span>是<span
class="math inline">\(G\)</span>的<strong>成真赋值</strong>；</p>
<p>如果公式<span class="math inline">\(G\)</span>在解释<span
class="math inline">\(I\)</span>下假，则称<span
class="math inline">\(I\)</span><strong>弄假于</strong><span
class="math inline">\(G\)</span>，此时<span
class="math inline">\(I\)</span>是<span
class="math inline">\(G\)</span>的<strong>成假赋值</strong>；</p>
<h4 id="真值表">真值表</h4>
<p>一般来说，若有<span
class="math inline">\(n\)</span>个命题变元，则应有<span
class="math inline">\(2^n\)</span>个不同的解释。</p>
<p>由公式G在其所有可能的解释下所取真值得到的表，称为<strong>真值表</strong>。</p>
<h3 id="命题公式分类和等价">3.5 命题公式分类和等价</h3>
<h4 id="命题公式分类">命题公式分类</h4>
<p>公式<span
class="math inline">\(G\)</span>称为<strong>永真公式</strong>（<strong>重言式</strong>），如果在它的所有解释之下都为真；</p>
<p>公式<span
class="math inline">\(G\)</span>称为<strong>永假公式</strong>（<strong>矛盾式</strong>），如果在它的所有解释之下都为假；</p>
<p>公式<span
class="math inline">\(G\)</span>称为<strong>可满足公式</strong>，如果它不是永假的。（因此，永真公式是一个可满足公式。）</p>
<p><span class="math inline">\(G\)</span>是永真的，当且仅当<span
class="math inline">\(\lnot G\)</span>是永假的。</p>
<p><span
class="math inline">\(G\)</span>是可满足的，当且仅当至少有一个解释，使<span
class="math inline">\(G\)</span>在<span
class="math inline">\(I\)</span>下为真。</p>
<p>若<span class="math inline">\(G\)</span>永真，则<span
class="math inline">\(G\)</span>可满足；但<strong>反之不成立</strong>。</p>
<h4 id="等价">等价</h4>
<p>设<span class="math inline">\(G, H\)</span>是两个命题公式，<span
class="math inline">\(P_1, P_2, \dots, P_n\)</span>是出现在<span
class="math inline">\(G, H\)</span>中所有的命题变元。如果对于<span
class="math inline">\(P_1, P_2, \dots, P_n\)</span>的<span
class="math inline">\(2^n\)</span>个解释，<span
class="math inline">\(G\)</span>与<span
class="math inline">\(H\)</span>的真值结果都相同，则称公式<span
class="math inline">\(G\)</span>与<span
class="math inline">\(H\)</span>是<strong>等价</strong>的，记作<span
class="math inline">\(G = H\)</span>或<span class="math inline">\(G
\Leftrightarrow H\)</span>。</p>
<p>对于任意两个公式G和H，<span class="math inline">\(G =
H\)</span>的<strong>充分必要条件</strong>是<span class="math inline">\(G
\leftrightarrow H\)</span>是永真公式。</p>
<p><strong>可判定性</strong>：能否给出一个可行方法，完成对任意公式的判定类问题。<strong>命题公式是可判定的。</strong></p>
<h3 id="命题等价公式及应用">3.6 命题等价公式及应用</h3>
<h4 id="命题等价公式">命题等价公式</h4>
<p>设<span class="math inline">\(G, H, S\)</span>为任意的命题公式。
<span class="math display">\[
E_1: G \lor G = G; \\
E_2: G \land G = G; \tag{幂等律}
\]</span></p>
<p><span class="math display">\[
E_3: G \lor H = H \lor G; \\
E_4: G \land H = H \land G; \tag{交换律}
\]</span></p>
<p><span class="math display">\[
E_5: G \lor (H \lor S) = (G \lor H) \lor S; \\
E_6: G \land (H \land S) = (G \land H) \land S; \tag{结合律}
\]</span></p>
<p><span class="math display">\[
E_7: G \lor 0 = G; \\
E_8: G \land 1 = G; \tag{同一律}
\]</span></p>
<p><span class="math display">\[
E_9: G \lor 1 = 1; \\
E_{10}: G \land 0 = 0; \tag{零律}
\]</span></p>
<p><span class="math display">\[
E_{11}: G \lor (H \land S) = (G \lor H) \land (G \lor S); \\
E_{12}: G \land (H \lor S) = (G \land H) \lor (G \land S); \tag{分配律}
\]</span></p>
<p><span class="math display">\[
E_{13}: G \lor (G \land H) = G; \\
E_{14}: G \land (G \lor H) = G; \tag{吸收律}
\]</span></p>
<p><span class="math display">\[
E_{15}: \lnot G \land G = 0; \tag{矛盾律}
\]</span></p>
<p><span class="math display">\[
E_{16}: \lnot G \lor G = 1; \tag{排中律}
\]</span></p>
<p><span class="math display">\[
E_{17}: \lnot (\lnot G) = G; \tag{双重否定律}
\]</span></p>
<p><span class="math display">\[
E_{18}: \lnot(G \lor H) = \lnot G \land \lnot H; \\
E_{19}: \lnot(G \land H) = \lnot G \lor \lnot H; \tag{德·摩根律}
\]</span></p>
<p><span class="math display">\[
E_{20}: G \to H = \lnot G \lor H; \tag{蕴涵式}
\]</span></p>
<p><span class="math display">\[
E_{21}: G \to H = \lnot H \to \lnot G; \tag{假言易位}
\]</span></p>
<p><span class="math display">\[
E_{22}: G \leftrightarrow H = (G \to H) \land (H \to G) = (\lnot G \lor
H) \land (\lnot H \lor G); \tag{等价式}
\]</span></p>
<p><span class="math display">\[
E_{23}: G \leftrightarrow H = \lnot G \leftrightarrow \lnot H;
\tag{等价否定等式}
\]</span></p>
<p><span class="math display">\[
E_{24}: (G \to H) \land (G \to \lnot H) = \lnot G; \tag{归谬论}
\]</span></p>
<h4 id="判断公式类型">判断公式类型</h4>
<h4 id="开关电路化简">开关电路化简</h4>
<h4 id="逻辑电路化简">逻辑电路化简</h4>
<h3 id="范式">3.7 范式</h3>
<h4 id="基本术语">基本术语</h4>
<p><strong>文字</strong>：命题变元或命题变元的否定。例如：<span
class="math inline">\(P\)</span></p>
<p>简单析取式（<strong>子句</strong>）：有限个文字的析取。例如：<span
class="math inline">\(P \lor Q \lor R\)</span>；<span
class="math inline">\(P\)</span>本身</p>
<p>简单合取式（<strong>短语</strong>）：有限个文字的合取。</p>
<p><strong>析取范式</strong>：有限个短语（简单合取式）的析取式。例如：<span
class="math inline">\((P \land Q) \lor (\lnot P \land R)\)</span>；<span
class="math inline">\(P \lor Q\)</span>；<span
class="math inline">\(P\)</span>本身</p>
<p><strong>合取范式</strong>：有限个子句（简单析取式）的合取式。</p>
<blockquote>
<p><span
class="math inline">\(P\)</span>是一个文字、短语、子句、析取范式、合取范式；</p>
<p><span class="math inline">\(P \lor Q \lor
R\)</span>是子句、合取范式、析取范式；</p>
<p><span class="math inline">\((P \lor Q \lor
R)\)</span>是子句、合取范式，<strong>但不是析取范式</strong>。</p>
<p><span class="math inline">\(P \lor (Q \lor
R)\)</span><strong>不是析取或合取范式</strong>，但去掉括号则是。</p>
<p>以<span
class="math inline">\(()\)</span>框起的部分算作一个整体，不可拆分。</p>
</blockquote>
<p>范式关注的是命题公式的当前书写形式。</p>
<p><strong>单个的文字</strong>是子句、短语、析取范式、合取范式。</p>
<p>析取、合取范式只含有联结词集<span class="math inline">\(\{\lnot,
\land, \lor\}\)</span>，且<span
class="math inline">\(\lnot\)</span>只能出现在命题变元前。</p>
<h4 id="范式存在定理">范式存在定理</h4>
<p><strong>定理</strong>  任意公式都存在与其等价的析取范式和合取范式。</p>
<p>命题公式的范式表达并不唯一。</p>
<h4 id="范式与真值">范式与真值</h4>
<p>命题公式的<strong>析取范式</strong>可以指出公式何时为<strong>真</strong>；</p>
<p>命题公式的<strong>合取范式</strong>可以指出公式何时为<strong>假</strong>。</p>
<h3 id="主范式">3.8 主范式</h3>
<h4 id="极小项和极大项">极小项和极大项</h4>
<p>在含有<span class="math inline">\(n\)</span>个命题变元<span
class="math inline">\(P_1, P_2, \dots,
P_n\)</span>的短语或子句中，若每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅一次，并且出现的次序与<span
class="math inline">\(P_1, P_2, \dots,
P_n\)</span>一致，则称此短语或子句为关于<span class="math inline">\(P_1,
P_2, \dots,
P_n\)</span>的一个<strong>极小项</strong>或<strong>极大项</strong>。</p>
<p><strong>极小项</strong>：短语。非<span
class="math inline">\(P\)</span>记为0，<span
class="math inline">\(P\)</span>记为1，<span class="math inline">\(\lnot
P \land Q \land R\)</span>记作<span
class="math inline">\(m_{011}\)</span>或<span
class="math inline">\(m_3\)</span>。</p>
<p><strong>极大项</strong>：子句。非<span
class="math inline">\(P\)</span>记为1，<span
class="math inline">\(P\)</span>记为0，<span class="math inline">\(\lnot
P \lor Q \lor R\)</span>记作<span
class="math inline">\(M_{100}\)</span>或<span
class="math inline">\(M_4\)</span>。</p>
<p><strong>性质</strong> <span class="math display">\[
m_i \land m_j = 0, \quad M_i \lor M_j = 1 (i \not= j) \\
m_i = \lnot M_i, \quad M_i = \lnot m_i \\
\bigvee_{i=0}^{2^n-1}m_i = 1, \quad \bigwedge_{i=0}^{2^n-1}M_i = 0
\]</span></p>
<h4 id="主析取范式和主合取范式">主析取范式和主合取范式</h4>
<p><strong>主析取范式</strong>：在给定的析取范式中，若每一个短语都是<strong>极小项</strong>，且按照编码从小到大的顺序排列，则称该范式为<strong>主析取范式</strong>。</p>
<p><strong>主合取范式</strong>：在给定的析取范式中，若每一个子句都是<strong>极大项</strong>，且按照编码从小到大的顺序排列，则称该范式为<strong>主合取范式</strong>。</p>
<p>如果一个主析取范式不包含任何极小项，则称该主析取范式为“<strong>空</strong>”；</p>
<p>如果一个主合取范式不包含任何极大项，则称该主合取范式为“<strong>空</strong>”；</p>
<p><strong>定理</strong>  任何一个公式都有与之等价的主析取范式和主合取范式。</p>
<p><strong>主范式求解定理</strong></p>
<ol type="1">
<li><p>求出该公式所对应的析取范式和合取范式；</p></li>
<li><p>消去重复出现的命题变元，矛盾式或重言式；</p></li>
<li><p>若析取（合取）范式的某一个短语（子句）中缺少命题变元<span
class="math inline">\(P\)</span>，则可用如下方式将<span
class="math inline">\(P\)</span>补进去：</p>
<p><span class="math inline">\(B_i = B_i \land 1 = B_i \land (\lnot P
\lor P) = (B_i \land \lnot P) \lor (B_i \land P)\)</span></p>
<p><span class="math inline">\(B_i = B_i \lor 0 = B_i \lor (\lnot P
\land P) = (B_i \lor \lnot P) \land (B_i \lor P)\)</span></p>
<p>重复至所有短语或子句都是标准的极小项或极大项为止。</p></li>
<li><p>利用幂等律将重复的极小项和极大项合并，并利用交换律进行顺序调整，由此可转换成标准的主析取范式和主合取范式。</p></li>
</ol>
<p><strong>真值表技术</strong></p>
<p>考虑任意公式<span
class="math inline">\(G\)</span>的主析取范式应该包含哪些极小项；</p>
<p>若某一种解释使得<span
class="math inline">\(G\)</span>为真，则这个解释构成的极小项包含在其主析取范式中。将所有这样的极小项找到，它们的析取即为<span
class="math inline">\(G\)</span>的主析取范式。</p>
<p>极大项反之。</p>
<p><strong>主范式的应用</strong></p>
<p>如果主析取范式包含所有的极小项，则该公式为永真公式；</p>
<p>如果主合取范式包含所有的极大项，则该公式为永假公式；</p>
<p>若两个公式具有相同的主析取范式或主合取范式，则两公式等价。</p>
<h3 id="基本推理形式和蕴含公式">3.9 基本推理形式和蕴含公式</h3>
<h4 id="推理形式">推理形式</h4>
<p><strong>推理</strong>：从一组前提合乎逻辑地推出结论的思维过程。</p>
<p>设<span class="math inline">\(G_1, G_2, \dots, G_n\)</span>和<span
class="math inline">\(H\)</span>是公式。</p>
<p>称<span class="math inline">\(H\)</span>是<span
class="math inline">\(G_1, G_2, \dots,
G_n\)</span>的<strong>逻辑结果</strong>，当且仅当对任意解释<span
class="math inline">\(I\)</span>，如果<span
class="math inline">\(I\)</span>使得<span class="math inline">\(G_1
\land G_2 \land \dots \land G_n\)</span>为真，则<span
class="math inline">\(I\)</span>也会使<span
class="math inline">\(H\)</span>为真。记为<span
class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow H\)</span>。</p>
<p><span
class="math inline">\(\Rightarrow\)</span>称为<strong>蕴含关系</strong>。此时称<span
class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow
H\)</span>为有效的，否则称为无效的。</p>
<p><span class="math inline">\(G_1, G_2, \dots,
G_n\)</span>称为一组<strong>前提</strong>，有时用集合<span
class="math inline">\(\Gamma\)</span>来表示，记为<span
class="math inline">\(\Gamma = \{G_1, G_2, \dots, G_n\}\)</span>。</p>
<p><span
class="math inline">\(H\)</span>称为<strong>结论</strong>。此时也称<span
class="math inline">\(H\)</span>是前提集合<span
class="math inline">\(\Gamma\)</span>的逻辑结果，记为<span
class="math inline">\(\Gamma \Rightarrow H\)</span>。</p>
<blockquote>
<p><span class="math inline">\(P \to Q, P \Rightarrow
Q\)</span>的优先级为<span class="math inline">\(((P \to Q), (P))
\Rightarrow Q\)</span>。等价于<span class="math inline">\(((P \to Q)
\land P) \to Q\)</span>。</p>
</blockquote>
<p><strong>推理的判定定理</strong></p>
<p><strong>定理</strong>  公式<span
class="math inline">\(H\)</span>是前提集合<span
class="math inline">\(\Gamma = \{G_1, G_2, \dots,
G_n\}\)</span>的逻辑结果，当且仅当<span class="math inline">\((G_1 \land
G_2 \land \dots \land G_n) \to H\)</span>永真。</p>
<p><strong>推理定律——基本蕴含关系</strong></p>
<p>设<span class="math inline">\(G, H, I\)</span>为任意的命题公式。
<span class="math display">\[
I_1: G \land H \Rightarrow G; \\
I_2: G \land H \Rightarrow H; \tag{简化规则}
\]</span></p>
<p><span class="math display">\[
I_3: G \Rightarrow G \lor H; \\
I_4: H \Rightarrow G \lor H; \tag{添加规则}
\]</span></p>
<p><span class="math display">\[
I_5: G, H \Rightarrow G \land H; \tag{合取引入规则}
\]</span></p>
<p><span class="math display">\[
I_6: G \lor H, \lnot G \Rightarrow H; \\
I_7: G \lor H, \lnot H \Rightarrow G; \tag{选言三段论}
\]</span></p>
<p><span class="math display">\[
I_8: G \to H, G \Rightarrow H; \tag{假言推理规则}
\]</span></p>
<p><span class="math display">\[
I_9: G \to H, \lnot H \Rightarrow \lnot G; \tag{否定后件式}
\]</span></p>
<p><span class="math display">\[
I_{10}: G \to H, H \to I \Rightarrow G \to I; \tag{假言三段论}
\]</span></p>
<p><span class="math display">\[
I_{11}: G \lor H, G \to I, H \to I \Rightarrow I; \tag{二难推论}
\]</span></p>
<h3 id="自然演绎法推理">3.10 自然演绎法推理</h3>
<h4 id="推理规则">推理规则</h4>
<p>前提引用规则（<strong>规则<span
class="math inline">\(P\)</span></strong>）：在推导的过程中，可随时引入前提集合中的任何一个前提</p>
<p>逻辑结果引用规则（<strong>规则<span
class="math inline">\(T\)</span></strong>）：在推导的过程中，可以随时引入公式<span
class="math inline">\(S\)</span>，该公式<span
class="math inline">\(S\)</span>是由其前的一个或多个公式推导出来的逻辑结果。</p>
<p>附加前提规则（<strong>规则<span
class="math inline">\(CP\)</span></strong>）：如果能从给定的前提集合<span
class="math inline">\(\Gamma\)</span>与公式<span
class="math inline">\(P\)</span>推导出<span
class="math inline">\(S\)</span>，则能从此前提集合<span
class="math inline">\(\Gamma\)</span>推导出<span class="math inline">\(P
\to S\)</span>。</p>
<h4 id="自然演绎法">自然演绎法</h4>
<p>从前提集合<span class="math inline">\(\Gamma\)</span>推出结论<span
class="math inline">\(H\)</span>的一个<strong>演绎</strong>是构造命题公式的一个有限序列：<span
class="math inline">\(H_1, H_2, \dots, H_{n-1},
H_n\)</span>，其中，<span class="math inline">\(H_i\)</span>或者是<span
class="math inline">\(\Gamma\)</span>中的某个<strong>前提</strong>，或者是前面的某些<span
class="math inline">\(H_j(j&lt;i)\)</span>的<strong>有效结论</strong>，并且<span
class="math inline">\(H_n\)</span>就是<span
class="math inline">\(H\)</span>，则称公式<span
class="math inline">\(H\)</span>为该演绎的<strong>有效结论</strong>，或者称从前提<span
class="math inline">\(\Gamma\)</span>能够<strong>演绎</strong>出结论<span
class="math inline">\(H\)</span>来。</p>
<p><strong>直接证明法</strong></p>
<blockquote>
<p>已知结论和条件，尝试倒推，“缺谁证谁”，即可写出证明。</p>
</blockquote>
<blockquote>
<p><strong>例</strong>：前提<span class="math inline">\(\Gamma = \{P \to
(Q \to S), \lnot R \lor P, Q\}\)</span>，结论<span
class="math inline">\(H = R \to S\)</span>。证明<span
class="math inline">\(\Gamma \Rightarrow H\)</span>。 <span
class="math display">\[
\begin{array} \\
(1) &amp; R &amp; P(附加前提)\\
(2) &amp; \lnot R \lor P &amp; P \\
(3) &amp; P &amp; T,(1),(2),I \\
(4) &amp; P \to (Q \to S) &amp; P \\
(5) &amp; Q \to S &amp; T,(3),(4),I \\
(6) &amp; Q &amp; P \\
(7) &amp; S &amp; T,(5),(6),I \\
(8) &amp; R \to S &amp; CP,(1),(7)
\end{array}
\]</span></p>
</blockquote>
<p><strong>间接证明法</strong></p>
<ul>
<li>反证法</li>
<li>归谬法</li>
</ul>
<p>要证明：<span class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow
H\)</span>，</p>
<p>根据判定定理：<span class="math inline">\((G_1 \land G_2 \land \dots
G_n) \to H\)</span>永真，</p>
<p>即，<span class="math inline">\(G_1 \land G_2 \land \dots G_n \land
\lnot H\)</span>矛盾。</p>
<p>因此：<span class="math inline">\(G_1 \land G_2 \land \dots G_n \land
\lnot H \Rightarrow R \land \lnot R\)</span>。得证。</p>
<blockquote>
<p>总可以不使用反证法而用规则<span
class="math inline">\(CP\)</span>代替。</p>
<p>也即，反证法是规则<span
class="math inline">\(CP\)</span>的一种变型。</p>
<p>反证法：<span class="math inline">\(G_1 \land G_2 \land \dots G_n
\land \lnot H \Rightarrow R \land \lnot R\)</span>，</p>
<p>根据规则<span class="math inline">\(CP\)</span>：<span
class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow \lnot H \to (R
\land \lnot R)\)</span>，</p>
<p>即，<span class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow
\lnot\lnot H \lor (R \land \lnot R)\)</span>。</p>
<p>即：<span class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow
H\)</span>。</p>
</blockquote>
<h3 id="联结词的完备集扩展内容">3.11 联结词的完备集〔扩展内容〕</h3>
<h4 id="联结词的扩充">联结词的扩充</h4>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 15%" />
<col style="width: 18%" />
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">联结词</th>
<th style="text-align: center;">记号</th>
<th style="text-align: center;">复合命题</th>
<th style="text-align: center;">读法</th>
<th style="text-align: center;">记法</th>
<th style="text-align: center;">真值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">异或</td>
<td style="text-align: center;"><span
class="math inline">\(\overline\lor\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>不可兼或<span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>异或<span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P
\overline\lor Q\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P,Q\)</span>真值不同时为真</td>
</tr>
<tr class="even">
<td style="text-align: center;">蕴涵否定</td>
<td style="text-align: center;"><span
class="math inline">\(\not\to\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>的蕴涵否定</td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>蕴涵否定<span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P \not\to
Q\)</span></td>
<td style="text-align: center;">只有<span
class="math inline">\(P\)</span>真<span
class="math inline">\(Q\)</span>假时为真</td>
</tr>
<tr class="odd">
<td style="text-align: center;">与非</td>
<td style="text-align: center;"><span
class="math inline">\(\uparrow\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>的与非</td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>与非<span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P \uparrow
Q\)</span></td>
<td style="text-align: center;">只有<span class="math inline">\(P,
Q\)</span>均为真时才为假</td>
</tr>
<tr class="even">
<td style="text-align: center;">或非</td>
<td style="text-align: center;"><span
class="math inline">\(\downarrow\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>的或非</td>
<td style="text-align: center;"><span
class="math inline">\(P\)</span>或非<span
class="math inline">\(Q\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P \downarrow
Q\)</span></td>
<td style="text-align: center;">只有<span class="math inline">\(P,
Q\)</span>均为假时才为真</td>
</tr>
</tbody>
</table>
<table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 27%" />
<col style="width: 18%" />
<col style="width: 20%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P
\overline\lor Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \not\to
Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \uparrow
Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \downarrow
Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(P \overline\lor Q \Leftrightarrow \lnot(P
\leftrightarrow Q)\)</span></p>
<p><span class="math inline">\(P \not\to Q \Leftrightarrow \lnot(P \to
Q)\)</span></p>
<p><span class="math inline">\(P \uparrow Q \Leftrightarrow \lnot(P
\land Q)\)</span></p>
<p><span class="math inline">\(P \downarrow Q \Leftrightarrow \lnot(P
\lor Q)\)</span></p>
<h4 id="联结词的完备集">联结词的完备集</h4>
<p>设<span class="math inline">\(S\)</span>是联结词集合，如果用<span
class="math inline">\(S\)</span>中的联结词表示的等价公式，可以表示任何命题公式，则称<span
class="math inline">\(S\)</span>是一个<strong>联结词完备集</strong>。</p>
<p>若<span class="math inline">\(S\)</span>是一个联结词完备集，而从<span
class="math inline">\(S\)</span>中删除任何一个联结词而得到的新联结词集合<span
class="math inline">\(S_1\)</span>，至少存在一个命题公式不能用<span
class="math inline">\(S_1\)</span>中的联结词表示的等价公式表示出来，则称<span
class="math inline">\(S\)</span>是一个<strong>极小完备</strong>的联结词集合。</p>
<ul>
<li><span class="math inline">\(\{\lnot, \lor\}\)</span></li>
<li><span class="math inline">\(\{\lnot, \land\}\)</span></li>
<li><span class="math inline">\(\{\lnot, \to\}\)</span></li>
<li><span class="math inline">\(\{\uparrow\}\)</span></li>
<li><span class="math inline">\(\{\downarrow\}\)</span></li>
</ul>
<h2 id="第四章-谓词逻辑">第四章 谓词逻辑</h2>
<h3 id="谓词的引入">4.1 谓词的引入</h3>
<p><strong>谓词逻辑</strong>（一阶逻辑）：为了研究简单命题句子内部的逻辑关系，利用个体词、谓词和量词来描述简单命题，以对简单命题进行分解，并研究个体与总体的内在联系和数量关系。</p>
<h4 id="个体词和谓词">个体词和谓词</h4>
<p>命题是具有真假意义的陈述句。从语法上分析，一个陈述句由主语和谓语两部分组成。</p>
<p><strong>个体词</strong>：在原子命题中，可以独立存在的客体（句子中的主语、宾语等）。</p>
<p><strong>谓词</strong>：用以刻画客体的性质或客体之间的关系。</p>
<p><strong>个体词</strong></p>
<ul>
<li><strong>个体常量</strong>：表示具体或特定的个体词。一般用带或不带下标的小写英文字母<span
class="math inline">\(a, b, c, \dots\)</span>表示。</li>
<li><strong>个体变量</strong>：表示抽象的或泛指的个体词。一般用带或不带下标的小写英文字母<span
class="math inline">\(x_1, y_1, z_1, \dots\)</span>表示。</li>
<li><strong>个体域</strong>（论域）：个体词的取值范围。常用<span
class="math inline">\(D\)</span>表示。</li>
<li><strong>全总个体域</strong>：宇宙间的所有个体域聚集在一起所构成的个体域。若无特别说明，均使用全总个体域。</li>
</ul>
<p><strong>谓词</strong></p>
<p>设<span class="math inline">\(D\)</span>为非空的个体域，定义在<span
class="math inline">\(D^n\)</span>（表示<span
class="math inline">\(n\)</span>个个体都在个体域<span
class="math inline">\(D\)</span>上取值）上取值于<span
class="math inline">\(\{0, 1\}\)</span>上的<span
class="math inline">\(n\)</span>元函数，称为<strong><span
class="math inline">\(n\)</span>元命题函数</strong>或<strong><span
class="math inline">\(n\)</span>元谓词</strong>，记为<span
class="math inline">\(P(x_1, x_2, \dots,
x_n)\)</span>。其中，个体变量<span class="math inline">\(x_1, x_2,
\dots, x_n \in D\)</span>。</p>
<ul>
<li><strong>谓词常量</strong>：表示具体性质或关系的谓词。</li>
<li><strong>谓词变量</strong>：表示抽象的或泛指的性质或关系的谓词。</li>
</ul>
<p>谓词均使用大写字母<span class="math inline">\(P, Q, R, \dots, F, G,
H, \dots\)</span>表示。</p>
<p>谓词中个体词的<strong>顺序不能随意变更</strong>。例，<span
class="math inline">\(F(b, c) \not= F(c, b)\)</span>。</p>
<p><strong>一元谓词</strong>用以描述某一个个体的某种<strong>特性</strong>，而<strong><span
class="math inline">\(n\)</span>元谓词</strong><span
class="math inline">\((n \geq 2)\)</span>则用以描述<span
class="math inline">\(n\)</span>个个体之间的<strong>关系</strong>。</p>
<p>谓词<span class="math inline">\(P(x_1, x_2, \dots,
x_n)\)</span>包含了个体变量和谓词变量，本身不是命题。只有用谓词常量取代<span
class="math inline">\(P\)</span>，用个体常量取代<span
class="math inline">\(x_1, x_2, \dots,
x_n\)</span>后，它才会成为命题。</p>
<p>一般将没有任何个体变量的谓词称为<strong>0元谓词</strong>，例如<span
class="math inline">\(F(a), G(a, b), H(a_1, a_2, \dots,
a_n)\)</span>等。当<span class="math inline">\(F, G,
H\)</span>为谓词常量时，0元谓词就成为了命题。此时，命题逻辑中的所有命题都可以表示为0元谓词。（即，0元谓词的谓词可以是常量或变量。当谓词是常量时，它同时也是命题。）</p>
<h4 id="复合命题的谓词符号化">复合命题的谓词符号化</h4>
<blockquote>
<p><strong>例</strong>：如果张三是一个三好学生，那么他的学习一定很好。</p>
<p>设<span class="math inline">\(S(x)\)</span>：<span
class="math inline">\(x\)</span>是一个三好学生，<span
class="math inline">\(H(x)\)</span>：<span
class="math inline">\(x\)</span>学习成绩好，<span
class="math inline">\(a\)</span>：张三</p>
<p>则该命题符号化为：<span class="math inline">\(S(a) \to
H(a)\)</span></p>
</blockquote>
<h3 id="量词的引入">4.2 量词的引入</h3>
<h4 id="量词">量词</h4>
<ul>
<li>全称量词<span class="math inline">\(\forall
x\)</span>：所有的、任意的、一切的、每一个……</li>
<li>存在量词<span class="math inline">\(\exist
x\)</span>：有些、至少有一个、某一些、存在……</li>
</ul>
<p>其中的<span
class="math inline">\(x\)</span>称为<strong>作用变量</strong>。一般将其量词加在其谓词之前，记为<span
class="math inline">\((\forall x)F(x), (\exist
x)F(x)\)</span>。此时，<span
class="math inline">\(F(x)\)</span>称为全称量词和存在量词的<strong>辖域</strong>。</p>
<p><strong>更准确的表达</strong></p>
<blockquote>
<p><strong>例</strong>：所有的老虎都要吃人。</p>
<p><strong>不准确的符号化表达</strong></p>
<p><span class="math inline">\(P(x)\)</span>：<span
class="math inline">\(x\)</span>要吃人。</p>
<p><span class="math inline">\((\forall x)P(x), x\in
\{老虎\}\)</span></p>
<p><strong>更准确的符号化表达</strong></p>
<p><span class="math inline">\(T(x)\)</span>：<span
class="math inline">\(x\)</span>是老虎，<span
class="math inline">\(P(x)\)</span>：<span
class="math inline">\(x\)</span>要吃人。</p>
<p><span class="math inline">\((\forall x)(T(x) \to P(x))\)</span></p>
</blockquote>
<blockquote>
<p><strong>例</strong>：有一些人登上过月球。</p>
<p><strong>不准确的符号化表达</strong></p>
<p><span class="math inline">\(R(x)\)</span>：<span
class="math inline">\(x\)</span>登上过月球。</p>
<p><span class="math inline">\((\exist x)R(x), x \in \{人\}\)</span></p>
<p><strong>更准确的符号化表达</strong></p>
<p><span class="math inline">\(H(x)\)</span>：<span
class="math inline">\(x\)</span>是人，<span
class="math inline">\(R(x)\)</span>：<span
class="math inline">\(x\)</span>登上过月球。</p>
<p><span class="math inline">\((\exist x)(H(x) \land R(x))\)</span></p>
</blockquote>
<h4 id="谓词逻辑符号化的两条规则">谓词逻辑符号化的两条规则</h4>
<p>统一个体域为全总个体域，而对于每一个句子中个体变量的变化范围用<strong>一元特性谓词</strong>刻画之。这种特性谓词在加入到命题函数中时必须遵循如下规则：</p>
<ul>
<li>对于<strong>全称量词</strong><span class="math inline">\(\forall
x\)</span>，刻画其对应个体域的特性谓词作为<strong>蕴涵式之前件</strong>加入；</li>
<li>对于<strong>存在量词</strong><span class="math inline">\(\exist
x\)</span>，刻画其对应个体域的特性谓词作为<strong>合取式之合取项</strong>加入。</li>
</ul>
<h4 id="量词相关的真值确定">量词相关的真值确定</h4>
<p>当个体域<span class="math inline">\(D = \{x_0, x_1, \dots,
x_n\}\)</span>是<strong>有限集合</strong>时，<span
class="math inline">\((\forall x)G(x)\)</span>和<span
class="math inline">\((\exist
x)G(x)\)</span>的真值可用与之等价的命题公式来进行表示。 <span
class="math display">\[
(\forall x)G(x) = G(x_0) \land G(x_1) \land \dots \land G(x_n) \\
(\exist x)G(x) = G(x_0) \lor G(x_1) \lor \dots \lor G(x_n)
\]</span></p>
<h3 id="谓词符号化举例">4.3 谓词符号化举例</h3>
<p><strong>谓词符号化</strong></p>
<blockquote>
<p><strong>例</strong>：没有人登上过木星。</p>
<p>令<span class="math inline">\(H(x)\)</span>：<span
class="math inline">\(x\)</span>是人，<span
class="math inline">\(M(x)\)</span>：<span
class="math inline">\(x\)</span>登上过木星。</p>
<p><span class="math inline">\(\lnot(\exist x)(H(x) \land
M(x))\)</span>或<span class="math inline">\((\forall x)(H(x) \to \lnot
M(x))\)</span></p>
</blockquote>
<blockquote>
<p><strong>例</strong>：在美国留学的学生未必都是亚洲人。</p>
<p>令<span class="math inline">\(A(x)\)</span>：<span
class="math inline">\(x\)</span>是亚洲人，<span
class="math inline">\(H(x)\)</span>：<span
class="math inline">\(x\)</span>是在美国留学的学生。</p>
<p><span class="math inline">\(\lnot(\forall x)(H(x) \to
A(x))\)</span>或<span class="math inline">\((\exist x)(H(x) \land \lnot
A(x))\)</span></p>
</blockquote>
<p><strong>二元谓词</strong></p>
<blockquote>
<p><strong>例</strong>：天下乌鸦一般黑。</p>
<p>令<span class="math inline">\(F(X)\)</span>：<span
class="math inline">\(x\)</span>是乌鸦，<span class="math inline">\(G(x,
y)\)</span>：<span class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>一般黑。</p>
<p><span class="math inline">\((\forall x)(\forall y)(F(x) \land F(y)
\to G(x, y))\)</span>或<span class="math inline">\(\lnot(\exist
x)(\exist)(F(x)\land F(y)\land \lnot G(x, y))\)</span></p>
</blockquote>
<p><strong>假定个体域</strong></p>
<blockquote>
<p><strong>例</strong>：每个实数都存在比它大的另外的实数。</p>
<p>令<span class="math inline">\(R(X)\)</span>：<span
class="math inline">\(x\)</span>是实数，<span class="math inline">\(L(x,
y)\)</span>：<span class="math inline">\(x\)</span>小于<span
class="math inline">\(y\)</span>。</p>
<p><span class="math inline">\((\forall x)(R(x) \to (\exist y)(R(y)\land
L(x, y)))\)</span>$</p>
<p>若假定<strong>个体域</strong>为所有实数，则命题符号化为<span
class="math inline">\((\forall x)(\exist y)L(x, y)\)</span></p>
</blockquote>
<p><strong>多句话</strong></p>
<blockquote>
<p><strong>例</strong>：所有狮子都是凶猛的；有些狮子不喝咖啡；有些凶猛的动物不喝咖啡。</p>
<p>令<span class="math inline">\(P(x)\)</span>：<span
class="math inline">\(x\)</span>是狮子；<span
class="math inline">\(Q(x)\)</span>：<span
class="math inline">\(x\)</span>是凶猛的；<span
class="math inline">\(R(x)\)</span>：<span
class="math inline">\(x\)</span>喝咖啡。</p>
<p>假定所有动物的集合为个体域。</p>
<p><span class="math inline">\((\forall x)(P(x) \to Q(x));\\(\exist
x)(P(x) \land \lnot R(x));\\(\exist x)(Q(x) \land \lnot
R(x))\)</span></p>
</blockquote>
<blockquote>
<p><strong>例</strong>：所有的蜂鸟都五彩斑斓；没有大鸟以蜜为生；不以蜜为生的鸟都色彩单调；蜂鸟都是小鸟。</p>
<p>令<span class="math inline">\(P(x)\)</span>：<span
class="math inline">\(x\)</span>是蜂鸟；<span
class="math inline">\(Q(x)\)</span>：<span
class="math inline">\(x\)</span>是大鸟；<span
class="math inline">\(R(x)\)</span>：<span
class="math inline">\(x\)</span>是以蜜为生的鸟；<span
class="math inline">\(S(x)\)</span>：<span
class="math inline">\(x\)</span>五彩斑斓。</p>
<p>假定所有鸟的集合为个体域。</p>
<p><span class="math inline">\((\forall x)(P(x) \to S(x));\\\lnot(\exist
x)(Q(x)\land R(x));\\(\forall x)(\lnot R(x) \to \lnot S(x));\\(\forall
x)(P(x) \to \lnot Q(x))\)</span></p>
</blockquote>
<p><strong>常量的使用</strong></p>
<blockquote>
<p><strong>例</strong>：只要是需要室外活动的课，郝亮都喜欢；所有的公共体育课都的需要室外活动的课；篮球是一门公共体育课；郝亮喜欢篮球这门课。</p>
<p>令<span class="math inline">\(O(x)\)</span>：<span
class="math inline">\(x\)</span>的需要室外活动的课；<span
class="math inline">\(L(x, y)\)</span>：<span
class="math inline">\(x\)</span>喜欢<span
class="math inline">\(y\)</span>；<span
class="math inline">\(S(x)\)</span>：<span
class="math inline">\(x\)</span>是一门公共体育课；<span
class="math inline">\(a\)</span>：郝亮；<span
class="math inline">\(b\)</span>：篮球。</p>
<p><span class="math inline">\((\forall x)(O(x) \to L(a, x));\\(\forall
x)(S(x) \to O(x));\\S(b);\\L(a, b)\)</span></p>
</blockquote>
<h3 id="谓词公式">4.4 谓词公式</h3>
<h4 id="符号">符号</h4>
<ul>
<li><strong>常量符号</strong>：指所属个体域<span
class="math inline">\(D\)</span>中的<strong>某个</strong>元素，用带或不带下表的小写英文字母表示。</li>
<li><strong>变量符号</strong>：指所属个体域<span
class="math inline">\(D\)</span>中的<strong>任意</strong>元素，用带或不带下表的小写英文字母表示。</li>
<li><strong>函数符号</strong>：<span
class="math inline">\(n\)</span>元函数符号<span
class="math inline">\(f(x_1, x_2, \dots,
x_n)\)</span>可以是所属个体域集合<span class="math inline">\(D^n \to
D\)</span>的任意一个<strong>函数</strong>，用带或不带下标的小写英文字母表示。</li>
<li><strong>谓词符号</strong>：<span
class="math inline">\(n\)</span>元函数符号<span
class="math inline">\(f(x_1, x_2, \dots,
x_n)\)</span>可以是所属个体域集合<span class="math inline">\(D^n \to
D\)</span>的任意一个<strong>谓词</strong>，用带或不带下标的大写英文字母表示。</li>
</ul>
<h4 id="项">项</h4>
<ol type="1">
<li><strong>任意的常量符号</strong>或<strong>任意的变量符号</strong>是项；</li>
<li>若<span class="math inline">\(f(x_1, x_2, \dots,
x_n)\)</span>是<span class="math inline">\(n\)</span>元函数符号，<span
class="math inline">\(t_1, t_2, \dots, t_n\)</span>是项，则<span
class="math inline">\(f(t_1, t_2, \dots, t_n)\)</span>是项；</li>
<li>仅由<strong>有限次</strong>使用以上两个规则产生的符号串才是项。</li>
</ol>
<h4 id="合式公式">合式公式</h4>
<p>若<span class="math inline">\(P(x_1, x_2, \dots, x_n)\)</span>是<span
class="math inline">\(n\)</span>元谓词，<span class="math inline">\(t_1,
t_2, \dots, t_n\)</span>是项，则称<span class="math inline">\(P(t_1,
t_2, \dots,
t_n)\)</span>为<strong>原子谓词公式</strong>，简称<strong>原子公式</strong>。</p>
<p><strong>合式公式</strong>（公式）</p>
<ol type="1">
<li><strong>原子公式</strong>是合式公式；</li>
<li>若<span class="math inline">\(G, H\)</span>是合式公式，则<span
class="math inline">\(\lnot G, \lnot H, G \lor H, G \land H, G \to H, G
\leftrightarrow H\)</span>也是合式公式；</li>
<li>由<strong>有限次</strong>使用以上三个规则产生的表达式才是合式公式。</li>
</ol>
<p>公式的最外层括号可省略。</p>
<p>量词后面的括号省略方式为：一个量词的辖域中仅出现一个原子公式，则此辖域的外层括号可省略，否则不能省略。</p>
<p>一个个体词只能受一个量词的约束，否则就是没有意义的。</p>
<h3 id="自由变元和约束变元">4.5 自由变元和约束变元</h3>
<h4 id="自由变元和约束变元-1">自由变元和约束变元</h4>
<p>给定一个合式公式<span class="math inline">\(G\)</span>，若变元<span
class="math inline">\(x\)</span>出现在使用变元的量词的辖域之内，则称变元<span
class="math inline">\(x\)</span>的出现为<strong>约束出现</strong>，此时的变元<span
class="math inline">\(x\)</span>称为<strong>约束变元</strong>。若<span
class="math inline">\(x\)</span>的出现不是约束出现，则称它为<strong>自由出现</strong>，此时的变元<span
class="math inline">\(x\)</span>称为<strong>自由变元</strong>。</p>
<p><strong>辖域</strong></p>
<ul>
<li>若量词后有括号，则括号内的子公式就是该量词的辖域；<span
class="math inline">\((\forall x)(\dots)\)</span></li>
<li>若量词后有括号，则与量词邻接的子公式就是该量词的辖域。<span
class="math inline">\((\forall x)F(x)\)</span></li>
</ul>
<p><strong>变元改名规则</strong></p>
<ul>
<li><strong>约束变元</strong>的改名规则
<ul>
<li>将量词中的变元以及该量词辖域中此变量之所有约束出现都用新的个体变元替换；</li>
<li>新的变元一定要有别于改名辖域中的所有其他变量。</li>
</ul></li>
<li><strong>自由变元</strong>的代入规则
<ul>
<li>将公式中出现该自由变元的每一处都用新的个体变元替换；</li>
<li>新的变元不允许在原公式中以任何约束形式出现。也可用个体常量代入。</li>
</ul></li>
</ul>
<h4 id="闭式">闭式</h4>
<p>设<span class="math inline">\(G\)</span>是任意一个公式。若<span
class="math inline">\(G\)</span>中无自由出现的个体变元，则称<span
class="math inline">\(G\)</span>为<strong>封闭的合式公式</strong>，简称<strong>闭式</strong>。</p>
<p>显然，<strong>闭式</strong>是一个<strong>命题</strong>。</p>
<h3 id="谓词公式的解释和分类">4.6 谓词公式的解释和分类</h3>
<h4 id="公式的解释-1">公式的解释</h4>
<p>谓词逻辑中公式<span class="math inline">\(G\)</span>的每一个解释<span
class="math inline">\(I\)</span>由如下四部分组成：</p>
<ul>
<li><strong>非空的个体域</strong>集合<span
class="math inline">\(D\)</span>；</li>
<li><span
class="math inline">\(G\)</span>中的每个<strong>常量符号</strong>，指定<span
class="math inline">\(D\)</span>中的某个特定的元素；</li>
<li><span class="math inline">\(G\)</span>中的每个<span
class="math inline">\(n\)</span>元函数符号，指定<span
class="math inline">\(D^n\)</span>到<span
class="math inline">\(D\)</span>中的某个特定的函数；</li>
<li><span class="math inline">\(G\)</span>中的每个<span
class="math inline">\(n\)</span>元谓词符号，指定<span
class="math inline">\(D^n\)</span>到<span class="math inline">\(\{0,
1\}\)</span>中的某个特定的谓词；</li>
</ul>
<p><strong>规定</strong>：公式中无自由变元，或将自由变元看成是常量符号。</p>
<h4 id="公式的分类">公式的分类</h4>
<p><strong>有效公式</strong>：公式<span
class="math inline">\(G\)</span>在它所有的解释下都取值为<strong>真</strong>。</p>
<p><strong>矛盾公式</strong>：公式<span
class="math inline">\(G\)</span>在它所有的解释下都取值为<strong>假</strong>。</p>
<p><strong>可满足公式</strong>：至少有一种解释使得公式<span
class="math inline">\(G\)</span>取值为<strong>真</strong>。</p>
<h4 id="公式的判定问题">公式的判定问题</h4>
<p>谓词逻辑是<strong>不可判定的</strong>；</p>
<p>只含有一元谓词变项的公式是<strong>可判定的</strong>；</p>
<p>如下形式的公式： <span class="math display">\[
(\forall x_1)(\forall x_2)\dots(\forall x_n)P(x_1, x_2, \dots, x_n) \\
(\exist x_1)(\exist x_2)\dots(\exist x_n)P(x_1, x_2, \dots, x_n)
\]</span> 若<span
class="math inline">\(P\)</span>中无量词和其他自由变元时，也是<strong>可判定的</strong>；</p>
<p>个体域有穷时的谓词公式是<strong>可判定的</strong>。</p>
<h3 id="谓词公式的等价关系">4.7 谓词公式的等价关系</h3>
<h4 id="等价-1">等价</h4>
<p>如果公式<span class="math inline">\(G \leftrightarrow
H\)</span>是有效公式，则公式<span class="math inline">\(G,
H\)</span>称为<strong>等价的</strong>，记为<span class="math inline">\(G
= H\)</span>。</p>
<p>设<span class="math inline">\(G(P_1, P_2, \dots,
P_n)\)</span>是命题演算中的命题公式，<span class="math inline">\(P_1,
P_2, \dots, P_n\)</span>是出现在<span
class="math inline">\(G\)</span>中的命题变元，当用任意的谓词公式<span
class="math inline">\(G_i(1 \leq i \leq n)\)</span>分别代入<span
class="math inline">\(P_i\)</span>后，得到的新谓词公式<span
class="math inline">\(G(G_1, G_2, \dots,
G_n)\)</span>称为原公式的<strong>代入实例</strong>。</p>
<p><strong>定理</strong>  <strong>永真公式</strong>的任意一个代入实例必为<strong>有效公式</strong>。</p>
<h4 id="谓词演算中的基本等价公式">谓词演算中的基本等价公式</h4>
<p>命题公式中的基本等价公式<span class="math inline">\(E_1, \dots,
E_{24}\)</span>在谓词演算中<strong>依然成立</strong>。</p>
<p>假设<span class="math inline">\(G(x),
H(x)\)</span>是只含自由变元<span
class="math inline">\(x\)</span>的公式，<span
class="math inline">\(S\)</span>是<strong>不含<span
class="math inline">\(x\)</span>的公式</strong>。则在全总个体域中有
<span class="math display">\[
E_{25}:(\exist x)G(x) = (\exist y)G(y); \\
E_{26}:(\forall x)G(x) = (\forall y)G(y); \tag{改名规则}
\]</span></p>
<p><span class="math display">\[
E_{27}: \lnot(\exist x)G(x) = (\forall x)\lnot G(x); \\
E_{28}: \lnot(\forall x)G(x) = (\exist x)\lnot G(x);
\tag{量词转换律/量词否定等价式}
\]</span></p>
<blockquote>
<p>下面四条公式<span class="math inline">\(E_{29}\)</span>~<span
class="math inline">\(E_{32}\)</span>中的<span
class="math inline">\(S\)</span><strong>不能有<span
class="math inline">\(x\)</span></strong>。</p>
</blockquote>
<p><span class="math display">\[
E_{29}:(\forall x)(G(x) \lor S) = (\forall x)G(x) \lor S; \\
E_{30}:(\forall x)(G(x) \land S) = (\forall x)G(x) \land S; \\
E_{31}:(\exist x)(G(x) \lor S) = (\exist x)G(x) \lor S; \\
E_{32}:(\exist x)(G(x) \land S) = (\exist x)G(x) \land S;
\tag{量词辖域的扩张与收缩律}
\]</span></p>
<p><span class="math display">\[
E_{33}:(\forall x)(G(x) \land H(x)) = (\forall x)G(x) \land (\forall
x)H(x); \\
E_{34}:(\exist x)(G(x) \lor H(x)) = (\exist x)G(x) \lor (\exist x)H(x);
\tag{量词分配律}
\]</span></p>
<p><span class="math inline">\(\forall\)</span>对<span
class="math inline">\(\lor\)</span><strong>不满足</strong>分配律；<span
class="math inline">\(\exist\)</span>对<span
class="math inline">\(\land\)</span><strong>不满足</strong>分配律。
<span class="math display">\[
E_{35}:(\forall x)G(x) \lor (\forall x)H(x) = (\forall x)(\forall
y)(G(x) \lor H(y)); \\
E_{36}:(\exist x)G(x) \land (\exist x)H(x) = (\exist x)(\exist y)(G(x)
\land H(y));
\]</span></p>
<p>对于多个量词的公式，设<span class="math inline">\(G(x,
y)\)</span>是含有自由变元<span class="math inline">\(x,
y\)</span>的谓词公式，则有 <span class="math display">\[
E_{37}:(\forall x)(\forall y)G(x, y) = (\forall y)(\forall x)G(x, y); \\
E_{38}:(\exist x)(\exist y)G(x, y) = (\exist y)(\exist x)G(x, y);
\]</span></p>
<h3 id="前束范式扩展内容">4.8 前束范式〔扩展内容〕</h3>
<h4 id="前束范式">前束范式</h4>
<p>称公式<span
class="math inline">\(G\)</span>是一个<strong>前束范式</strong>，如果<span
class="math inline">\(G\)</span>中的一切量词都位于该公式的最前端（不含否定词）且这些量词的辖域都延伸至公式的末端。</p>
<p>其标准形式如下： <span class="math display">\[
(Q_1x_1)(Q_2x_2)\dots(Q_nx_n)M(x_1, x_2, \dots, x_n)
\]</span> 其中<span class="math inline">\(Q_i\)</span>为量词<span
class="math inline">\(\forall\)</span>或<span
class="math inline">\(\exist\)</span><span class="math inline">\((i = 1,
\dots, n)\)</span>，<span class="math inline">\(M\)</span>称作公式<span
class="math inline">\(G\)</span>的<strong>母式（基式）</strong>，<span
class="math inline">\(M\)</span>中不再有量词。</p>
<h4 id="前束范式的求解步骤">前束范式的求解步骤</h4>
<ol type="1">
<li><strong>消去</strong>公式中的联结词<span class="math inline">\(\to,
\leftrightarrow\)</span>（如果有的话）；</li>
<li>反复运用量词转换律、德摩根律和双重否定律，直到将所有的<span
class="math inline">\(\lnot\)</span>都<strong>内移</strong>到原子谓词公式的前端；</li>
<li>使用谓词的等价公式将所有量词提到公式的<strong>最前端</strong>并保证其辖域直到公式的末端。</li>
</ol>
<h3 id="推理形式和推理规则">4.9 推理形式和推理规则</h3>
<h4 id="推理形式-1">推理形式</h4>
<p>设<span class="math inline">\(G_1, G_2, \dots, G_n,
H\)</span>是公式，称<span class="math inline">\(H\)</span>是<span
class="math inline">\(G_1, G_2, \dots,
G_n\)</span>的<strong>逻辑结果</strong>（或称<span
class="math inline">\(G_1, G_2, \dots, G_n\)</span>共同蕴涵<span
class="math inline">\(H\)</span>），当且仅当对任意解释<span
class="math inline">\(I\)</span>，若<span
class="math inline">\(I\)</span>同时满足<span class="math inline">\(G_1,
G_2, \dots, G_n\)</span>，则<span
class="math inline">\(I\)</span>满足<span
class="math inline">\(H\)</span>，记为<span class="math inline">\(G_1,
G_2, \dots, G_n \Rightarrow H\)</span>，此时称<span
class="math inline">\(G_1, G_2, \dots, G_n \Rightarrow
H\)</span>是有效的，否则称为无效的。<span class="math inline">\(G_1,
G_2, \dots, G_n\)</span>称为一组前提，有时用集合<span
class="math inline">\(\Gamma\)</span>来表示，记<span
class="math inline">\(\Gamma = \{G_1, G_2, \dots, G_n\}\)</span>，<span
class="math inline">\(H\)</span>称为结论，又称<span
class="math inline">\(H\)</span>是前提集合<span
class="math inline">\(\Gamma\)</span>的逻辑结果，记为<span
class="math inline">\(\Gamma \Rightarrow H\)</span>。</p>
<p><strong>定理</strong>  设<span class="math inline">\(G_1, G_2, \dots,
G_n, H\)</span>是公式，公式<span
class="math inline">\(H\)</span>是前提集合<span
class="math inline">\(\Gamma = \{G_1, G_2, \dots,
G_n\}\)</span>的逻辑结果，当且仅当<span class="math inline">\(G_1 \land
G_2 \land \dots \land G_n \to H\)</span>为有效公式。</p>
<h4 id="推理规律">推理规律</h4>
<p>命题演算中的基本蕴涵公式<span
class="math inline">\(I_1\)</span>~<span
class="math inline">\(I_{11}\)</span>在谓词演算中仍然成立。</p>
<p>假设<span class="math inline">\(G(x),
H(x)\)</span>是只含自由变元<span
class="math inline">\(x\)</span>的公式，则有全总个体域中，有 <span
class="math display">\[
I_{12}:(\forall x)G(x) \Rightarrow (\exist x)G(x);
\]</span></p>
<p><span class="math display">\[
I_{13}:(\forall x)G(x) \lor (\forall x)H(x) \Rightarrow (\forall x)(G(x)
\lor H(x)); \\
I_{14}:(\exist  x)(G(x) \land H(x)) \Rightarrow (\exist x)G(x) \land
(\forall x)H(x);
\]</span></p>
<p><span class="math display">\[
I_{15}:(\forall x)(G(x) \to H(x)) \Rightarrow (\forall x)G(x) \to
(\forall x)H(x); \\
I_{16}:(\forall x)(G(x) \to H(x)) \Rightarrow (\exist x)G(x) \to (\exist
x)H(x);
\]</span></p>
<p>对于多个量词的公式，设<span class="math inline">\(G(x,
y)\)</span>是含有自由变元<span class="math inline">\(x,
y\)</span>的谓词公式，则有 <span class="math display">\[
I_{17}:(\exist x)(\forall y)G(x, y) \Rightarrow (\forall y)(\exist
x)G(x, y); \\
I_{18}:(\forall x)(\forall y)G(x, y) \Rightarrow (\exist y)(\exist
x)G(x, y); \\
I_{19}:(\forall y)(\forall x)G(x, y) \Rightarrow (\exist x)(\forall
y)G(x, y); \\
I_{20}:(\exist y)(\forall x)G(x, y) \Rightarrow (\forall x)(\exist
y)G(x, y); \\
I_{21}:(\forall x)(\exist y)G(x, y) \Rightarrow (\exist y)(\exist x)G(x,
y); \\
I_{22}:(\forall y)(\exist x)G(x, y) \Rightarrow (\exist x)(\exist y)G(x,
y);
\]</span></p>
<p><strong>全称特指规则US</strong></p>
<p><span class="math inline">\((\forall x)G(x) \Rightarrow
G(y)\)</span>，<span class="math inline">\(y\)</span>不在<span
class="math inline">\(G(x)\)</span>中约束出现。</p>
<p>或：<span class="math inline">\((\forall x)G(x) \Rightarrow
G(c)\)</span>，<span
class="math inline">\(c\)</span>为<strong>任意</strong>个体常量。</p>
<p><strong>存在特指规则ES</strong></p>
<p><span class="math inline">\((\exist x)G(x) \Rightarrow
G(c)\)</span>，<span class="math inline">\(c\)</span>为使得<span
class="math inline">\(G(c)\)</span>为真的<strong>特定</strong>的个体常量。</p>
<p>当<span class="math inline">\(G(x)\)</span>中还有除<span
class="math inline">\(x\)</span>之外的自由变元（例如<span
class="math inline">\(y\)</span>），则必须用关于这些变元的函数符号（例如<span
class="math inline">\(f(y)\)</span>）来取代<span
class="math inline">\(c\)</span>。</p>
<p><strong>全称推广规则UG</strong></p>
<p><span class="math inline">\(G(y) \Rightarrow (\forall
x)G(x)\)</span>，<span class="math inline">\(G(y)\)</span>中无变元<span
class="math inline">\(x\)</span>。</p>
<p><strong>存在推广规则EG</strong></p>
<p><span class="math inline">\(G(c) \Rightarrow (\exist
x)G(x)\)</span>，<span
class="math inline">\(c\)</span>为特定个体常量。</p>
<p>或：<span class="math inline">\(G(y) \Rightarrow (\exist
x)G(x)\)</span>，<span class="math inline">\(G(y)\)</span>中无变元<span
class="math inline">\(x\)</span>。</p>
<h3 id="综合推理方法">4.10 综合推理方法</h3>
<h4 id="谓词的演绎推理">谓词的演绎推理</h4>
<p>假定推导过程都是在相同的个体域内进行的（通常是全总个体域）。</p>
<p><strong>综合推理方法</strong></p>
<ul>
<li>推导过程中可以引用命题演算中的<strong>规则P</strong>和<strong>规则T</strong>；</li>
<li>如果结论是以<strong>条件形式</strong>或<strong>析取形式</strong>给出，则可使用<strong>规则CP</strong>；</li>
<li>若需<strong>消去量词</strong>，可以引用<strong>规则US</strong>和<strong>规则ES</strong>；</li>
<li>当所求结论需<strong>定量</strong>时，可引用<strong>规则UG</strong>和<strong>规则EG</strong>引入量词；</li>
<li>证明时可采用如命题演算中的<strong>直接证明方法</strong>和<strong>间接证明方法</strong>；</li>
<li>在推导过程中，对消去量词的公式或公式中<strong>不含量词的子公式</strong>，可以引用命题演算中的<strong>基本等价公式</strong>和<strong>基本蕴涵公式</strong>；</li>
<li>在推导过程中，对<strong>含有量词的公式</strong>可以引用谓词中的<strong>基本等价公式</strong>和<strong>基本蕴涵公式</strong>。</li>
</ul>
<blockquote>
<p><strong>例</strong>：证明<span class="math inline">\((\forall x)(P(x)
\to Q(x)), (\exist x)P(x) \Rightarrow (\exist x)Q(x)\)</span> <span
class="math display">\[
\begin{array} \\
(1) &amp; (\exist x)P(x) &amp; P \\
(2) &amp; P(a) &amp; ES, (1), I \\
(3) &amp; (\forall x)(P(x) \to Q(x)) &amp; P \\
(4) &amp; P(a) \to Q(a) &amp; US, (3) \\
(5) &amp; Q(a) &amp; T, (2), (4), I \\
(6) &amp; (\exist x)Q(x) &amp; EG, (5)
\end{array}
\]</span></p>
</blockquote>
<p><strong>难点</strong>：</p>
<ul>
<li>在推导过程中，如既要使用<strong>规则US</strong>又要使用<strong>规则ES</strong>消去量词，而且<strong>选用的个体是同一个符号</strong>，则必须<strong>先使用规则ES，再使用规则US</strong>。然后再使用命题演算中的推理规则，最后使用规则UG或规则EG引入量词，得到所求结论。</li>
<li>如一个变量是用<strong>规则ES</strong>消去量词，对该变量在添加量词时，则<strong>只能使用规则EG</strong>；如使用<strong>规则US</strong>消去量词，对该变量在添加量词时，则<strong>可使用规则EG和规则UG</strong>。</li>
<li>在用<strong>规则US</strong>和<strong>规则ES</strong>消去量词时，此量词必须位于<strong>整个公式的最前端</strong>，且<strong>辖域为其后的整个公式</strong>。</li>
<li>在添加量词<span class="math inline">\((\forall x)\)</span>和<span
class="math inline">\((\exist x)\)</span>时，所选用的<span
class="math inline">\(x\)</span>不能在公式<span
class="math inline">\(G(y)\)</span>或<span
class="math inline">\(G(c)\)</span>中出现。</li>
</ul>
<blockquote>
<p><strong>例</strong>：反证法</p>
<p>证明<span class="math inline">\((\forall x)(P(x) \lor Q(x))
\Rightarrow (\forall x)P(x) \lor (\exist x)Q(x)\)</span> <span
class="math display">\[
\begin{array} \\
(1) &amp; \lnot((\forall x)P(x) \lor (\exist x)Q(x)) &amp; P(附加前提)
\\
(2) &amp; \lnot(\forall x)P(x) \land \lnot(\exist x)Q(x) &amp; T, (1), E
\\
(3) &amp; \lnot(\forall x)P(x) &amp; T, (2), I \\
(4) &amp; \lnot(\exist x)Q(x) &amp; T, (2), I \\
(5) &amp; (\exist x)\lnot P(x) &amp; T, (3), E \\
(6) &amp; \lnot P(c) &amp; ES, (5) \\
(7) &amp; (\forall x)\lnot Q(x) &amp; T, (4), E \\
(8) &amp; \lnot Q(c) &amp; US, (7) \\
(9) &amp; \lnot P(c) \land \lnot Q(c) &amp; T, (6), (8), I \\
(10) &amp; \lnot(P(c) \lor Q(c)) &amp; T, (9), E \\
(11) &amp; (\forall x)(P(x) \lor Q(x)) &amp; P
\end{array}
\]</span></p>
</blockquote>
<p>如有两个含有存在量词的公式，当用<strong>规则ES</strong>消去量词时，不能选用同样的一个常量符号来取代两个公式中的变元，而应用<strong>不同的常量符号</strong>来取代它们。</p>
<h2 id="第五章-证明技术">第五章 证明技术</h2>
<h3 id="证明定理的方法">5.2 证明定理的方法</h3>
<p>在定理证明中，如果将证明中的已知看成是命题逻辑中的前提，将证明的结果看成是命题逻辑中的结论，则大多数定理都是一个蕴涵关系。</p>
<p>要证明逻辑关系<span class="math inline">\(P \Rightarrow
Q\)</span>，只需证明蕴涵式<span class="math inline">\(P \to
Q\)</span>为永真公式。</p>
<h4 id="基本证明技术">基本证明技术</h4>
<p><strong>直接证明</strong></p>
<p><strong>间接证明</strong></p>
<p>因为<span class="math inline">\(P \to Q\)</span>等价于<span
class="math inline">\(\lnot Q \to \lnot P\)</span>。</p>
<h4 id="几种典型的证明技术">几种典型的证明技术</h4>
<p><strong>空证明</strong>：<span class="math inline">\(P = 0, Q = 0
\Rightarrow P \to Q = 1\)</span></p>
<p><strong>平凡证明</strong>：<span class="math inline">\(Q = 1
\Rightarrow P \to Q = 1\)</span></p>
<p><strong>归谬法证明</strong>：反证法</p>
<p><strong>分情形证明</strong>：</p>
<p>为了证明形如<span class="math inline">\(P_1 \lor P_2 \lor \dots \lor
P_n \to Q\)</span>的蕴含式，可以用重言式<span class="math inline">\(P_1
\lor P_2 \lor \dots \lor P_n \to Q == (P_1 \to Q) \land (P_2 \to Q)
\land \dots \land (P_n \to
Q)\)</span>来作为推理规则。这个推理规则说明，可以通过对<span
class="math inline">\(i = 1, 2, \dots, n\)</span>分别证明每个蕴含式<span
class="math inline">\((P_i \to Q)\)</span>来证明由命题<span
class="math inline">\(P_1, P_2, \dots,
P_n\)</span>的析取式组成前件的原来的蕴含式。这种论证称为<strong>分情形证明</strong>。</p>
<p><strong>等价性证明</strong>：</p>
<p>为了证明一个定理是双条件的，即形如<span class="math inline">\(P
\leftrightarrow Q\)</span>的命题，其中<span
class="math inline">\(P\)</span>和<span
class="math inline">\(Q\)</span>都是命题，可以使用重言式： <span
class="math display">\[
P \leftrightarrow Q = (P \to Q) \land (Q \to P)
\]</span> 即，如果证明了蕴含式“若<span
class="math inline">\(P\)</span>则<span
class="math inline">\(Q\)</span>”和“若<span
class="math inline">\(Q\)</span>则<span
class="math inline">\(P\)</span>”，那么就可以证明命题“<span
class="math inline">\(P\)</span>，当且仅当<span
class="math inline">\(Q\)</span>”。</p>
<h4 id="存在性证明">存在性证明</h4>
<p><strong>构造性证明</strong></p>
<p><strong>惟一性证明</strong></p>
<h3 id="数学归纳法">5.3 数学归纳法</h3>
<h4 id="数学归纳法原理">数学归纳法原理</h4>
<p>假设要证明的命题能写成形式： <span class="math display">\[
\forall n \geq n_0, 有P(n)
\]</span> 其中<span
class="math inline">\(n_0\)</span>是某个固定的整数。</p>
<p>即：希望证明对所有的整数<span class="math inline">\(n \geq
n_0\)</span>都有<span class="math inline">\(P(n)\)</span>为真。</p>
<p><strong>假设</strong></p>
<ol type="1">
<li><strong>归纳基础</strong>：验证<span class="math inline">\(n =
n_0\)</span>，有<span class="math inline">\(P(n_0)\)</span>为真；</li>
<li><strong>归纳假设</strong>：假设对于<span class="math inline">\(n =
k(k \geq n_0)\)</span>，有<span
class="math inline">\(P(k)\)</span>为真；</li>
<li><strong>归纳结论</strong>：证明<span class="math inline">\(n =
k+1\)</span>，有<span class="math inline">\(P(k+1)\)</span>为真。</li>
</ol>
<p><strong>结论</strong>  对所有的整数<span class="math inline">\(n \geq
n_0\)</span>，都有<span class="math inline">\(P(n)\)</span>为真。</p>
<h4 id="强形式数学归纳法原理">强形式数学归纳法原理</h4>
<p><strong>假设</strong></p>
<ol type="1">
<li><strong>归纳基础</strong>：验证<span class="math inline">\(n = n_0,
n = n_0+1\)</span>，有<span class="math inline">\(P(n_0),
P(n_0+1)\)</span>为真；</li>
<li><strong>归纳假设</strong>：假设对于<span class="math inline">\(n
\leq k(k \geq n_0)\)</span>，有<span
class="math inline">\(P(n)\)</span>为真；</li>
<li><strong>归纳结论</strong>：证明<span class="math inline">\(n =
k+1\)</span>，有<span class="math inline">\(P(k+1)\)</span>为真。</li>
</ol>
<p><strong>结论</strong>  对所有的整数<span class="math inline">\(n \geq
n_0\)</span>，都有<span class="math inline">\(P(n)\)</span>为真。</p>
<h2 id="第六章-二元关系">第六章 二元关系</h2>
<h3 id="序偶和笛卡尔积">6.1 序偶和笛卡尔积</h3>
<h4 id="有序组的定义">有序组的定义</h4>
<p>由两个元素按照一定的次序组成的二元组称为<strong>序偶</strong>，记作<span
class="math inline">\(\left&lt;x, y\right&gt;\)</span>。其中<span
class="math inline">\(x\)</span>是<strong>第一元素</strong>，<span
class="math inline">\(y\)</span>是<strong>第二元素</strong>。</p>
<p>两个序偶<span class="math inline">\(\left&lt;a, b\right&gt; =
\left&lt;c, d\right&gt;\)</span>，当且仅当<span class="math inline">\(a
= c\)</span>且<span class="math inline">\(b = d\)</span>。</p>
<h4 id="笛卡儿积">笛卡儿积</h4>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，称集合<span
class="math inline">\(A \times B = \{\left&lt;x, y\right&gt;|(x \in A)
\land (y \in B)\}\)</span>为集合<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>笛卡儿积</strong>。</p>
<p><strong>性质</strong></p>
<ul>
<li>设<span class="math inline">\(A,
B\)</span>是任意两个集合，则不一定有<span class="math inline">\(A \times
B = B \times A\)</span>，即笛卡儿积<strong>不满足交换律</strong>；</li>
<li><span class="math inline">\(A \times B =
\varnothing\)</span>，当且仅当<span class="math inline">\(A =
\varnothing\)</span>或者<span class="math inline">\(B =
\varnothing\)</span>；</li>
<li>设<span class="math inline">\(A, B,
C\)</span>是任意三个集合，则不一定有<span class="math inline">\(A \times
(B \times C) = (A \times B) \times
C\)</span>，即笛卡儿积<strong>不满足结合律</strong>；</li>
<li>当集合<span class="math inline">\(A,
B\)</span>都是<strong>有限集</strong>时，<span class="math inline">\(|A
\times B| = |B \times A| = |A| \times |B|\)</span>；</li>
<li>笛卡儿积对<strong>并运算</strong>和<strong>交运算</strong>满足<strong>分配律</strong>。</li>
</ul>
<h4 id="推广">推广</h4>
<p>由<span class="math inline">\(n\)</span>个元素<span
class="math inline">\(a_1, a_2, \dots,
a_n\)</span>按照一定次序组成的<span
class="math inline">\(n\)</span>元组称为<strong><span
class="math inline">\(n\)</span>重有序组</strong>，记作<span
class="math inline">\(\left&lt;a_1, a_2, \dots, a_n
\right&gt;\)</span>，其中<span
class="math inline">\(a_1\)</span>是<strong>第一个元素</strong>，<span
class="math inline">\(a_2\)</span>是<strong>第二个元素</strong>，……，<span
class="math inline">\(a_n\)</span>是<strong>第<span
class="math inline">\(n\)</span>个元素</strong>。</p>
<p>设<span class="math inline">\(A_1, A_2, \dots, A_n\)</span>是<span
class="math inline">\(n\)</span>个集合，称集合<span
class="math inline">\(A_1 \times A_2 \times \dots \times A_n =
\{\left&lt;a_1, a_2, \dots, a_n\right&gt; | a_i \in A_i, i = 1, 2, 3,
\dots, n\}\)</span>为集合<span class="math inline">\(A_1, A_2, \dots,
A_n\)</span>的<strong>笛卡儿积</strong>。当<span
class="math inline">\(A_1 = A_2 = \dots = A_n = A\)</span>时，可记<span
class="math inline">\(A_1 \times A_2 \times \dots \times A_n =
A^n\)</span>。</p>
<p><strong>性质</strong></p>
<ul>
<li>两个<span class="math inline">\(n\)</span>重有序组<span
class="math inline">\(\left&lt;a_1, a_2, \dots, a_n\right&gt; =
\left&lt;b_1, b_2, \dots, b_n\right&gt;\)</span>，当且仅当<span
class="math inline">\(a_i = b_i, i = 1, 2, \dots, n\)</span>；</li>
<li>当集合<span class="math inline">\(A_1, A_2, \dots,
A_n\)</span>都是有限集时，<span class="math inline">\(|A_1 \times A_2
\times \dots \times A_n| = |A_1| \times |A_2| \times \dots \times
|A_n|\)</span>。</li>
</ul>
<h3 id="关系的定义">6.2 关系的定义</h3>
<h4 id="二元关系">二元关系</h4>
<p>设<span class="math inline">\(A, B\)</span>为两个非空集合，称<span
class="math inline">\(A \times B\)</span>的任意子集<span
class="math inline">\(R\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的一个<strong>二元关系</strong>，简称<strong>关系</strong>。</p>
<p>其中，<span class="math inline">\(A\)</span>称为关系<span
class="math inline">\(R\)</span>的<strong>前域</strong>，<span
class="math inline">\(B\)</span>称为关系<span
class="math inline">\(R\)</span>的<strong>后域</strong>。如果<span
class="math inline">\(A = B\)</span>，则称<span
class="math inline">\(R\)</span>为<span
class="math inline">\(A\)</span>上的一个<strong>二元关系</strong>。</p>
<p><strong>数学符号</strong></p>
<ul>
<li>若序偶<span class="math inline">\(\left&lt;x, y\right&gt; \in
R\)</span>，通常把这一事实记为<span
class="math inline">\(xRy\)</span>，读作“<span
class="math inline">\(x\)</span>对<span
class="math inline">\(y\)</span>有关系<span
class="math inline">\(R\)</span>”；</li>
<li>若序偶<span class="math inline">\(\left&lt;x, y\right&gt; \not\in
R\)</span>，通常把这一事实记为<span class="math inline">\(x\not
Ry\)</span>，读作“<span class="math inline">\(x\)</span>对<span
class="math inline">\(y\)</span>没有关系<span
class="math inline">\(R\)</span>”。</li>
</ul>
<p><strong>几种重要关系</strong></p>
<ul>
<li>当<span class="math inline">\(R = \varnothing\)</span>时，称<span
class="math inline">\(R\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>空关系</strong>；</li>
<li>当<span class="math inline">\(R = A \times B\)</span>时，称<span
class="math inline">\(R\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>全关系</strong>；<span
class="math inline">\(A\)</span>上的全关系通常记为<span
class="math inline">\(E_A\)</span>。</li>
<li>当<span class="math inline">\(R = I_a = \{\left&lt;x, x\right&gt; |
x \in A\}\)</span>时，称<span class="math inline">\(R\)</span>为<span
class="math inline">\(A\)</span>上的<strong>恒等关系</strong>。</li>
</ul>
<p><strong>有限集合的二元关系数量</strong></p>
<p>当集合<span class="math inline">\(A, B\)</span>都是有限集时，<span
class="math inline">\(A \times B\)</span>共有<span
class="math inline">\(|A| \times
|B|\)</span>个不同的元素，这些元素将会产生<span
class="math inline">\(2^{|A| \times
|B|}\)</span>个不同的子集。即，从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的不同关系共有<span
class="math inline">\(2^{|A| \times |B|}\)</span>个。</p>
<h4 id="定义域和值域">定义域和值域</h4>
<p>设<span class="math inline">\(R\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的二元关系，则<span
class="math inline">\(A\)</span>为关系<span
class="math inline">\(R\)</span>的前域，<span
class="math inline">\(B\)</span>为关系<span
class="math inline">\(R\)</span>的后域。令<span class="math inline">\(C
= \{x | x \in A, \exist y \in B, \left&lt;x, y\right&gt; \in R\}, D =
\{y | y \in B, \exist y \in B, \left&lt;x, y\right&gt; \in
R\}\)</span>。</p>
<p>称<span class="math inline">\(C\)</span>为<span
class="math inline">\(R\)</span>的<strong>定义域</strong>，记为<span
class="math inline">\(C = \operatorname{dom}R\)</span>；</p>
<p><span class="math inline">\(D\)</span>为<span
class="math inline">\(R\)</span>的<strong>值域</strong>，记为<span
class="math inline">\(D = \operatorname{ran}R\)</span>；</p>
<p><span class="math inline">\(\operatorname{fld}R = \operatorname{dom}R
\cup \operatorname{ran}R\)</span>为<span
class="math inline">\(R\)</span>的<strong>域</strong>。</p>
<h4 id="二元关系概念的推广">二元关系概念的推广</h4>
<p>设<span class="math inline">\(A_1, A_2, \dots, A_n\)</span>为<span
class="math inline">\(n\)</span>个非空集合，称<span
class="math inline">\(A_1 \times A_2 \times \dots \times
A_n\)</span>的任意子集<span class="math inline">\(R\)</span>为<span
class="math inline">\(A_1, A_2, \dots, A_n\)</span>中的一个<strong><span
class="math inline">\(n\)</span>元关系</strong>。</p>
<p>在<span
class="math inline">\(n\)</span>元关系中，最常用的是二元关系，因而，在不引起混淆的情况下，提到的关系均指二元关系。</p>
<h3 id="关系的表示">6.3 关系的表示</h3>
<h4 id="关系的集合表示">关系的集合表示</h4>
<p>关系是一种特殊的集合，因此集合的两种基本表示法（<strong>枚举法</strong>和<strong>叙述法</strong>），可以用到关系的表示中。</p>
<h4 id="关系的图形表示">关系的图形表示</h4>
<p>设<span class="math inline">\(A = \{a_1, a_2, \dots, a_n\}, B =
\{b_1, b_2, \dots, b_m\}\)</span>，<span
class="math inline">\(R\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的一个关系。</p>
<ul>
<li>集合中的元素<span class="math inline">\(a_1, a_2, \dots,
a_n\)</span>和<span class="math inline">\(b_1, b_2, \dots,
b_m\)</span>分别作为图中的结点，用“<span
class="math inline">\(\circ\)</span>”表示；</li>
<li>如果<span class="math inline">\(\left&lt;a_i, b_j\right&gt; \in
R\)</span>，则从<span class="math inline">\(a_i\)</span>到<span
class="math inline">\(b_j\)</span>可用一有向边<span
class="math inline">\(a_i \longrightarrow b_j\)</span>相连。</li>
</ul>
<figure>
<img src="https://s1.ax1x.com/2020/04/17/JEscPs.png" alt="JEscPs.png" />
<figcaption aria-hidden="true">JEscPs.png</figcaption>
</figure>
<ul>
<li>如果<span class="math inline">\(\left&lt;a_i, a_i\right&gt; \in
R\)</span>，则从<span class="math inline">\(a_i\)</span>到<span
class="math inline">\(a_i\)</span>可用一带箭头的小圆圈<span
class="math inline">\(a_i
\mathop\circlearrowleft\limits^{\circ}\)</span>表示，即画一个自环。</li>
</ul>
<figure>
<img src="https://s1.ax1x.com/2020/04/17/JEs4qU.png" alt="JEs4qU.png" />
<figcaption aria-hidden="true">JEs4qU.png</figcaption>
</figure>
<h4 id="关系的矩阵表示">关系的矩阵表示</h4>
<p>设<span class="math inline">\(A = \{a_1, a_2, \dots, a_n\}, B =
\{b_1, b_2, \dots, b_m\}\)</span>，<span
class="math inline">\(R\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的一个二元关系，称矩阵<span
class="math inline">\(M_R = (m_{ij})_{n \times m}\)</span>为关系<span
class="math inline">\(R\)</span>的<strong>关系矩阵</strong>，其中<span
class="math inline">\(m_{ij} = \begin{cases}1 &amp; \left&lt;a_i,
b_j\right&gt; \in R \\ 0 &amp; \left&lt; a_i, b_j\right&gt; \not\in
R\end{cases}, (1 \leq i \leq m, 1 \leq j \leq n)\)</span>又称<span
class="math inline">\(M_R\)</span>为<span
class="math inline">\(R\)</span>的<strong>邻接矩阵</strong>。</p>
<blockquote>
<p>例：上面<strong>选课关系<span
class="math inline">\(R\)</span></strong>的邻接矩阵 <span
class="math display">\[
M_R = \begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\]</span></p>
</blockquote>
<h4 id="布尔矩阵的并和交运算">布尔矩阵的并和交运算</h4>
<p>如果<span class="math inline">\(A = (a_{ij})\)</span>和<span
class="math inline">\(B = (b_{ij})\)</span>是两个<span
class="math inline">\(m \times n\)</span>矩阵，则<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的<strong>并</strong>也是一个<span
class="math inline">\(m \times n\)</span>矩阵，记为<span
class="math inline">\(A \lor B = C = (c_{ij})\)</span>。其中： <span
class="math display">\[
c_{ij} = \begin{cases}1 &amp; {\rm if}\ a_{ij} = 1\ {\rm or}\ b_{ij} = 1
\\0 &amp; {\rm if}\ a_{ij} = 0\ {\rm and}\ b_{ij} = 0\end{cases}
\]</span></p>
<p>如果<span class="math inline">\(A = (a_{ij})\)</span>和<span
class="math inline">\(B = (b_{ij})\)</span>是两个<span
class="math inline">\(m \times n\)</span>矩阵，则<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的<strong>交</strong>也是一个<span
class="math inline">\(m \times n\)</span>矩阵，记为<span
class="math inline">\(A \land B = C = (c_{ij})\)</span>。其中： <span
class="math display">\[
c_{ij} = \begin{cases}1 &amp; {\rm if}\ a_{ij} = 1\ {\rm and}\ b_{ij} =
1 \\0 &amp; {\rm if}\ a_{ij} = 0\ {\rm or}\ b_{ij} = 0\end{cases}
\]</span></p>
<h4 id="布尔矩阵的积运算">布尔矩阵的积运算</h4>
<p>如果<span class="math inline">\(A = (a_{ij})\)</span>是<span
class="math inline">\(m \times p\)</span>矩阵，<span
class="math inline">\(B = (b_{ij})\)</span>是<span
class="math inline">\(p \times n\)</span>矩阵，则<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>的<strong>积</strong>是一个<span
class="math inline">\(m \times n\)</span>矩阵，记为<span
class="math inline">\(A \odot B = C = (c_{ij})\)</span>。其中： <span
class="math display">\[
c_{ij} = \begin{cases}
1 &amp; \exist k, a_{ik} = 1\ {\rm and}\ b_{kj} = 1 \\
0 &amp; {\rm else}
\end{cases}
\]</span></p>
<h3 id="关系的运算">6.4 关系的运算</h3>
<h4 id="关系的并交差补运算">关系的并交差补运算</h4>
<p>关系是一种特殊的集合，因此集合的所有基本运算（并、交、差、补），都可以应用到关系中，并且同样满足集合的所有运算定律。</p>
<p>设<span class="math inline">\(R, S\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的两个关系，则 <span
class="math display">\[
\begin{aligned}
R \cup S &amp;= \{\left&lt;x, y\right&gt; | (xRy) \lor(xSy)\} \\
R \cap S &amp;= \{\left&lt;x, y\right&gt; | (xRy) \land(xSy) \} \\
R - S &amp;= \{\left&lt;x, y\right&gt; | (xRy) \land(x\not Sy) \} \\
\overline R &amp;= \{\left&lt;x, y\right&gt; | (x\not Ry)\}（即全集为A
\times B）
\end{aligned}
\]</span></p>
<h4 id="关系的复合运算">关系的复合运算</h4>
<p>设<span class="math inline">\(A, B, C\)</span>是三个集合，<span
class="math inline">\(R\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的关系，<span
class="math inline">\(S\)</span>是从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的关系（即<span class="math inline">\(R:
A \to B, S: B \to C\)</span>），则<span
class="math inline">\(R\)</span>与<span
class="math inline">\(S\)</span>的<strong>复合关系</strong>（合成关系）<span
class="math inline">\(R \circ S\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的关系，并且：<span
class="math inline">\(R \circ S = \{\left&lt;x, z\right&gt; | (x \in A)
\land (z \in C) \land (\exist y)(y \in B \land xRy \land
ySz)\}\)</span>。运算“<span
class="math inline">\(\circ\)</span>”称为<strong>复合运算</strong>。</p>
<p><strong>用三种关系表示法进行复合运算</strong></p>
<figure>
<img src="https://s1.ax1x.com/2020/04/20/J1GAIg.png" alt="J1GAIg.png" />
<figcaption aria-hidden="true">J1GAIg.png</figcaption>
</figure>
<ul>
<li><strong>集合表示法</strong>：寻找所有满足<span
class="math inline">\(\left&lt;x, y\right&gt; \in R\)</span>且<span
class="math inline">\(\left&lt;y, z\right&gt; \in
S\)</span>，从而得到<span class="math inline">\(\left&lt;x, z\right&gt;
\in R \circ S\)</span>；</li>
<li><strong>关系图表示法</strong>：将关系<span class="math inline">\(R,
S\)</span>的关系图画在一起，然后寻找所有首尾相接的两条有向边，再去掉中间相接的结点<span
class="math inline">\(y\)</span>，可得到<span class="math inline">\(R
\circ S\)</span>的关系图；</li>
<li><strong>关系矩阵表示法</strong>：将关系<span
class="math inline">\(R\)</span>和<span
class="math inline">\(S\)</span>的关系矩阵做布尔积运算，即得<span
class="math inline">\(R \circ S\)</span>的关系矩阵。</li>
</ul>
<h4 id="关系的逆运算">关系的逆运算</h4>
<p>设<span class="math inline">\(A, B\)</span>是两个集合，<span
class="math inline">\(R\)</span>是<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的关系，则从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(A\)</span>的关系<span class="math inline">\(R^{-1}
= \{\left&lt;b, a\right&gt; | \left&lt;a, b\right&gt; \in
R\}\)</span>称为<span
class="math inline">\(R\)</span>的<strong>逆关系</strong>，运算"<span
class="math inline">\(^{-1}\)</span>"称为<strong>逆运算</strong>。</p>
<p><strong>用三种关系表示法求逆</strong></p>
<figure>
<img src="https://s1.ax1x.com/2020/04/20/J1G4w8.png" alt="J1G4w8.png" />
<figcaption aria-hidden="true">J1G4w8.png</figcaption>
</figure>
<ul>
<li><strong>集合表示法</strong></li>
<li><strong>关系图表示法</strong>：将<span
class="math inline">\(R\)</span>的关系图中有向边的方向改变成相反方向即得<span
class="math inline">\(R^{-1}\)</span>的关系图，反之亦然；</li>
<li><strong>关系矩阵表示法</strong>：将关系<span
class="math inline">\(R\)</span>的关系矩阵转置即得<span
class="math inline">\(R^{-1}\)</span>的关系矩阵，即<span
class="math inline">\(R\)</span>和<span
class="math inline">\(R^{-1}\)</span>的关系矩阵互为转置矩阵；</li>
<li><span class="math inline">\(R^{-1}\)</span>的定义域和值域正好是<span
class="math inline">\(R\)</span>的值域和定义域，即<span
class="math inline">\(\operatorname{dom}R = \operatorname{ran}R^{-1},
\operatorname{dom}R^{-1} = \operatorname{ran}R\)</span>；</li>
<li><span class="math inline">\(|R| = |R^{-1}|\)</span>。</li>
</ul>
<h3 id="关系的运算定律">6.5 关系的运算定律</h3>
<h4 id="结合律与同一律">结合律与同一律</h4>
<p>设<span class="math inline">\(A, B, C,
D\)</span>是任意四个集合，<span class="math inline">\(R, S,
T\)</span>分别 是从<span class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>、<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>、<span
class="math inline">\(C\)</span>到<span
class="math inline">\(D\)</span>的二元关系，<span
class="math inline">\(I_A, I_B\)</span>分别是<span
class="math inline">\(A, B\)</span>上的恒等关系，则 <span
class="math display">\[
(R \circ S) \circ T = R \circ (S \circ T) \\
I_A \circ R = R \circ I_B = R
\]</span> <strong>二元关系相等的证明方法</strong></p>
<p>目标：证明两个关系<span class="math inline">\(R_1,
R_2\)</span>相等。</p>
<p>也即证明两个集合<span class="math inline">\(R_1,
R_2\)</span>相等。从而，</p>
<ul>
<li><span class="math inline">\(\forall \left&lt;x, y\right&gt; \in R_1,
\dots, \left&lt;x, y\right&gt; \in R_2. \therefore R_1 \subseteq
R_2\)</span>；</li>
<li><span class="math inline">\(\forall \left&lt;x, y\right&gt; \in R_2,
\dots, \left&lt;x, y\right&gt; \in R_1. \therefore R_2 \subseteq
R_1\)</span>。</li>
</ul>
<h4 id="分配律">分配律</h4>
<p>设<span class="math inline">\(A, B, C,
D\)</span>是任意四个集合，<span
class="math inline">\(R\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的关系， <span
class="math inline">\(S_1, S_2\)</span>是从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的关系，<span
class="math inline">\(T\)</span>是从<span
class="math inline">\(C\)</span>到<span
class="math inline">\(D\)</span>的关系，则 <span class="math display">\[
\begin{aligned}
R \circ (S_1 \cup S_2) &amp;= (R \circ S_1) \cup (R \circ S_2) \\
R \circ (S_1 \cap S_2) &amp;\subseteq (R \circ S_1) \cap (R \circ S_2)
\\
(S_1 \cup S_2) \circ T &amp;= (S_1 \circ T) \cup (S_2 \circ T)
\end{aligned}
\]</span> 分配律==反之不成立==。</p>
<h4 id="逆运算性质定律">逆运算性质定律</h4>
<p>设<span class="math inline">\(A, B, C\)</span>是三个集合，<span
class="math inline">\(R, S\)</span>分别是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>、从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的关系，则 <span class="math display">\[
(R \circ S)^{-1} = S^{-1} \circ R^{-1}
\]</span></p>
<p><span class="math display">\[
(R \cup S)^{-1} = S^{-1} \cup R^{-1} \\
(R \cap S)^{-1} = S^{-1} \cap R^{-1} \\
(R - S)^{-1} = S^{-1} - R^{-1} \tag{分配性}
\]</span></p>
<p><span class="math display">\[
(\overline R)^{-1} = \overline{R^{-1}} \tag{可换性}
\]</span></p>
<p><span class="math display">\[
(R^{-1})^{-1} = R
\]</span></p>
<p><span class="math display">\[
S \subseteq R \Leftrightarrow S^{-1} \subseteq R^{-1} \tag{单调性}
\]</span></p>
<h3 id="关系的幂运算">6.6 关系的幂运算</h3>
<h4 id="关系的幂运算-1">关系的幂运算</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的关系，则<span
class="math inline">\(R\)</span>的<span
class="math inline">\(n\)</span>次幂记为<span
class="math inline">\(R^n\)</span>，定义如下：</p>
<ol type="1">
<li><span class="math inline">\(R^0 = I_A\)</span>;</li>
<li><span class="math inline">\(R^1 = R\)</span>；</li>
<li><span class="math inline">\(R^{n+1} = R^n \circ R = R \circ
R^n\)</span>。</li>
</ol>
<p><span class="math inline">\(R^n\)</span>仍然是<span
class="math inline">\(A\)</span>上的关系，表示<span
class="math inline">\(R\)</span>多次自我复合的结果；</p>
<p><span class="math inline">\(R^{m+n} = R^m \circ R^n = R^n \circ R^m =
R^{n+m}\)</span>；</p>
<p><span class="math inline">\((R^m)^n = R^{mn}, m, n \in
N\)</span>。</p>
<h4 id="幂运算的性质">幂运算的性质</h4>
<blockquote>
<p><span class="math inline">\(R_n\)</span>的基数并非随着<span
class="math inline">\(n\)</span>的增加而增加，而是呈递减趋势。</p>
<p>当<span class="math inline">\(n \geq |A|\)</span>时，则<span
class="math inline">\(R^n \subseteq
\bigcup_{i=1}^{|A|}R^i\)</span>。</p>
</blockquote>
<p><strong>定理</strong>  设<span
class="math inline">\(A\)</span>是有限集合，且<span
class="math inline">\(|A| = n\)</span>，<span
class="math inline">\(R\)</span>是<span
class="math inline">\(A\)</span>上的关系，则 <span
class="math display">\[
\bigcup_{i=1}^\infty R^i = \bigcup_{i=1}^n R^i
\]</span></p>
<h3 id="关系的性质一">6.7 关系的性质（一）</h3>
<h4 id="自反性与反自反性">自反性与反自反性</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的关系。</p>
<ul>
<li>如果对任意的<span class="math inline">\(x \in A\)</span>，都有<span
class="math inline">\(\left&lt;x, x\right&gt; \in
R\)</span>，那么称<span class="math inline">\(R\)</span>在<span
class="math inline">\(A\)</span>上是<strong>自反的</strong>，或称<span
class="math inline">\(R\)</span>具有<strong>自反性</strong>；</li>
<li>如果对任意的<span class="math inline">\(x \in A\)</span>，都有<span
class="math inline">\(\left&lt;x, x\right&gt; \not\in
R\)</span>，那么称<span class="math inline">\(R\)</span>在<span
class="math inline">\(A\)</span>上是<strong>反自反的</strong>，或称<span
class="math inline">\(R\)</span>具有<strong>反自反性</strong>。</li>
</ul>
<p>存在<strong>既不是自反的也不是反自反</strong>的关系；</p>
<p>关系<span class="math inline">\(R\)</span>是<strong>自反的</strong>，
当且仅当<span
class="math inline">\(R\)</span>的关系图中每个结点都有自环；关系<span
class="math inline">\(R\)</span>是<strong>反自反的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系图中每个结点都无自环；</p>
<p>关系<span
class="math inline">\(R\)</span>是<strong>自反的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系矩阵的主对角线上全为1；关系<span
class="math inline">\(R\)</span>是<strong>反自反的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系矩阵的主对角线上全为0。</p>
<h4 id="对称性与反对称性">对称性与反对称性</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的关系。</p>
<ul>
<li>如果对任意的<span class="math inline">\(x, y \in
A\)</span>，如果<span class="math inline">\(\left&lt;x, y\right&gt; \in
R\)</span>，那么<span class="math inline">\(\left&lt;y, x\right&gt; \in
R\)</span>，则称<span
class="math inline">\(R\)</span>是<strong>对称的</strong>， 或称<span
class="math inline">\(R\)</span>具有<strong>对称性</strong>；</li>
<li>如果对任意的<span class="math inline">\(x, y \in
A\)</span>，如果<span class="math inline">\(\left&lt;x, y\right&gt; \in
R\)</span>且<span class="math inline">\(\left&lt;y, x\right&gt; \in
R\)</span>，那么<span class="math inline">\(x = y\)</span>，则称<span
class="math inline">\(R\)</span>是<strong>反对称的</strong>， 或称<span
class="math inline">\(R\)</span>具有<strong>反对称性</strong>。</li>
</ul>
<p>存在<strong>既不是对称的也不是反对称</strong>的关系，也存在<strong>既是对称又是反对称</strong>的关系；</p>
<blockquote>
<p><span class="math inline">\(\left&lt;1,
1\right&gt;\)</span>既是<strong>对称的</strong>，又是<strong>反对称的</strong>。</p>
<p>因为，反对称要求在<span class="math inline">\(x \not=
y\)</span>时没有对称关系；在<span class="math inline">\(x =
y\)</span>时，没有要求。</p>
</blockquote>
<p>关系<span
class="math inline">\(R\)</span>是<strong>对称的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系图中，任何一对结点之间，要么有方向相反的两条边，要么无边；关系<span
class="math inline">\(R\)</span>是<strong>反对称的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系图中，任何一对结点之间至多只有一条边；</p>
<p>关系<span
class="math inline">\(R\)</span>是<strong>对称的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系矩阵<span
class="math inline">\((r_{ij})_{n \times
n}\)</span>为对称矩阵；关系<span
class="math inline">\(R\)</span>是<strong>反对称的</strong>，当且仅当<span
class="math inline">\(R\)</span>的关系矩阵<span
class="math inline">\((r_{ij})_{n \times n}\)</span>满足<span
class="math inline">\(i \not= j\)</span>时，<span
class="math inline">\(r_{ij} = 0\)</span>或<span
class="math inline">\(r_{ji} = 0\)</span>。</p>
<h4 id="传递性">传递性</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的关系。对任意的<span
class="math inline">\(x, y, z \in A\)</span>，如果<span
class="math inline">\(\left&lt;x, y\right&gt; \in R\)</span>且<span
class="math inline">\(\left&lt;y, z\right&gt; \in R\)</span>，那么<span
class="math inline">\(\left&lt;x, z\right&gt; \in R\)</span>，则称<span
class="math inline">\(R\)</span>是<strong>传递的</strong>，或称<span
class="math inline">\(R\)</span>具有<strong>传递性</strong>。</p>
<blockquote>
<p>一个特殊例子：<span class="math inline">\(R = \{\left&lt;1,
2\right&gt;\}\)</span>是<strong>传递的</strong>。</p>
</blockquote>
<p>关系<span
class="math inline">\(R\)</span>是<strong>传递的</strong>，当且仅当在<span
class="math inline">\(R\)</span>的关系图中，任何三个不同结点<span
class="math inline">\(x, y, z\)</span>之间，若从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(y\)</span>有一条边存在，从<span
class="math inline">\(y\)</span>到<span
class="math inline">\(z\)</span>有一条边存在，则从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(z\)</span>一定有一条边存在；</p>
<p>关系<span
class="math inline">\(R\)</span>是<strong>传递的</strong>，当且仅当在<span
class="math inline">\(R\)</span>的关系矩阵中，对任意<span
class="math inline">\(i, j, k \in \{1, 2, \dots, n\}\)</span>，若<span
class="math inline">\(r_{ij} = 1\)</span>且<span
class="math inline">\(r_{jk} = 1\)</span>，必有<span
class="math inline">\(r_{ik} = 1\)</span>。</p>
<h3 id="关系的性质二">6.8 关系的性质（二）</h3>
<h4 id="关系性质的判定定理">关系性质的判定定理</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的关系，则</p>
<ul>
<li><span class="math inline">\(R\)</span>是自反的<span
class="math inline">\(\Leftrightarrow I_A \subseteq R\)</span>；</li>
<li><span class="math inline">\(R\)</span>是反自反的<span
class="math inline">\(\Leftrightarrow R \cap I_A =
\varnothing\)</span>；</li>
<li><span class="math inline">\(R\)</span>是对称的<span
class="math inline">\(\Leftrightarrow R = R^{-1}\)</span>；</li>
<li><span class="math inline">\(R\)</span>是反对称的<span
class="math inline">\(\Leftrightarrow R \cap R^{-1} \subseteq
I_A\)</span>；</li>
<li><span class="math inline">\(R\)</span>是传递的<span
class="math inline">\(\Leftrightarrow R \circ R \subseteq
R\)</span>。</li>
</ul>
<h4 id="关系性质判定">关系性质判定</h4>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th>自反性</th>
<th>反自反性</th>
<th>对称性</th>
<th>反对称性</th>
<th>传递性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">定义</td>
<td><span class="math inline">\(\forall x \in A\)</span>，有<span
class="math inline">\(\left&lt;x, x\right&gt; \in R\)</span></td>
<td><span class="math inline">\(\forall x \in A\)</span>，有<span
class="math inline">\(\left&lt;x, x\right&gt; \notin R\)</span></td>
<td><span class="math inline">\(\forall x, y \in A\)</span>，若<span
class="math inline">\(\left&lt;x, y\right&gt; \in R\)</span>，则<span
class="math inline">\(\left&lt;y, x\right&gt; \in R\)</span></td>
<td><span class="math inline">\(\forall x, y \in A\)</span>，若<span
class="math inline">\(\left&lt;x, y\right&gt; \in R\)</span>且<span
class="math inline">\(\left&lt;y, x\right&gt; \in R\)</span>，则<span
class="math inline">\(x = y\)</span></td>
<td><span class="math inline">\(\forall x, y, z \in A\)</span>，若<span
class="math inline">\(\left&lt;x, y\right&gt; \in R\)</span>且<span
class="math inline">\(\left&lt;y, z\right&gt; \in R\)</span>，则<span
class="math inline">\(\left&lt;x, z\right&gt; \in R\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">关系运算</td>
<td><span class="math inline">\(I_A \subseteq R\)</span></td>
<td><span class="math inline">\(R \cap I_A = \varnothing\)</span></td>
<td><span class="math inline">\(R = R^{-1}\)</span></td>
<td><span class="math inline">\(R \cap R^{-1} \subseteq
I_A\)</span></td>
<td><span class="math inline">\(R \circ R \subseteq R\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">关系图</td>
<td>每个结点都有环</td>
<td>每个结点都无环</td>
<td>任两结点间，要么没有边，要么有方向相反的两条边</td>
<td>任两结点间，至多有一条边</td>
<td>如果从<span class="math inline">\(x\)</span>到<span
class="math inline">\(y\)</span>有边，从<span
class="math inline">\(y\)</span>到<span
class="math inline">\(z\)</span>有边，则从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(z\)</span>一定有边</td>
</tr>
<tr class="even">
<td style="text-align: right;">关系矩阵</td>
<td>主对角线上全为1</td>
<td>主对角线上全为0</td>
<td>对称矩阵<span class="math inline">\(M_R = M_R^T\)</span></td>
<td><span class="math inline">\(\forall i \not= j, r_{ij} =
0\)</span>或<span class="math inline">\(r_{ji} = 0\)</span></td>
<td><span class="math inline">\(\forall i, j, k\)</span>，若<span
class="math inline">\(r_{ij} = 1\)</span>且<span
class="math inline">\(r_{jk} = 1\)</span>，必有<span
class="math inline">\(r_{ik} = 1\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p>一个关系可能满足多种性质，如：</p>
<ul>
<li>非空集合<span class="math inline">\(A\)</span>上的全关系<span
class="math inline">\(E_A\)</span>：自反，对称，传递</li>
<li>非空集合<span class="math inline">\(A\)</span>上的空关系<span
class="math inline">\(\varnothing\)</span>：反自反，对称，反对称，传递</li>
<li>非空集合<span class="math inline">\(A\)</span>上的恒等关系<span
class="math inline">\(I_A\)</span>：自反，对称，反对称，传递</li>
<li>实数集<span class="math inline">\(R\)</span>上的等于关系<span
class="math inline">\(=\)</span>：自反，对称，反对称，传递</li>
<li>幂集上的真包含关系<span
class="math inline">\(\subset\)</span>：反自反，反对称，传递</li>
</ul>
</blockquote>
<h4 id="关系性质的保守性">关系性质的保守性</h4>
<p>设<span class="math inline">\(R, S\)</span>是集合<span
class="math inline">\(A\)</span>上的关系， 则</p>
<ul>
<li>若<span class="math inline">\(R,
S\)</span>是<strong>自反的</strong>，则<span
class="math inline">\(R^{-1}, R \cup S, R \cap S, R \circ
S\)</span>也是<strong>自反的</strong>；（<span class="math inline">\(R -
S\)</span>不是自反的）</li>
<li>若<span class="math inline">\(R,
S\)</span>是<strong>反自反的</strong>，则<span
class="math inline">\(R^{-1}, R \cup S, R \cap S, R -
S\)</span>也是<strong>反自反的</strong>；（<span class="math inline">\(R
\circ S\)</span>不是反自反的）</li>
<li>若<span class="math inline">\(R,
S\)</span>是<strong>对称的</strong>，则<span
class="math inline">\(R^{-1}, R \cup S, R \cap S, R -
S\)</span>也是<strong>对称的</strong>；（<span class="math inline">\(R
\circ S\)</span>不是反自反的）</li>
<li>若<span class="math inline">\(R,
S\)</span>是<strong>反对称的</strong>，则<span
class="math inline">\(R^{-1}, R \cap S, R -
S\)</span>也是<strong>反对称的</strong>；（<span class="math inline">\(R
\cup S, R \circ S\)</span>不是反自反的）</li>
<li>若<span class="math inline">\(R,
S\)</span>是<strong>传递的</strong>，则<span
class="math inline">\(R^{-1}, R\cap
S\)</span>也是<strong>传递的</strong>。（<span class="math inline">\(R
\cup S, R - S, R \circ S\)</span>不是传递的）</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: center;"><span
class="math inline">\(R^{-1}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R \cap
S\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R \cup
S\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R -
S\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R \circ
S\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">自反</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: right;">反自反</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">对称</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">反对称</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">传递</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h2 id="第七章-特殊关系">第七章 特殊关系</h2>
<h3 id="等价关系">7.1 等价关系</h3>
<h4 id="等价关系定义">等价关系定义</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的关系。如果<span
class="math inline">\(R\)</span>是<strong>自反的</strong>、<strong>对称的</strong>、<strong>传递的</strong>，则称<span
class="math inline">\(R\)</span>为<span
class="math inline">\(A\)</span>上的<strong>等价关系</strong>。</p>
<blockquote>
<p>等价关系的关系图类似下图：</p>
<figure>
<img src="https://s1.ax1x.com/2020/04/26/Jgd3IH.png" alt="Jgd3IH.png" />
<figcaption aria-hidden="true">Jgd3IH.png</figcaption>
</figure>
<p>即，等价关系是多个“小集合”的<strong>全关系</strong>组合而成。</p>
</blockquote>
<blockquote>
<p>要<strong>证明</strong>一个等价关系，就要证明该关系是<strong>自反的</strong>、<strong>对称的</strong>、<strong>传递的</strong>。</p>
</blockquote>
<h4 id="等价类">等价类</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的等价关系，对任意<span
class="math inline">\(x \in A\)</span>，称集合<span
class="math inline">\([x]_R = \{y | y \in A, \left&lt;x, y\right&gt; \in
R\}\)</span>为<span class="math inline">\(x\)</span>关于<span
class="math inline">\(R\)</span>的<strong>等价类</strong>，或叫做由<span
class="math inline">\(x\)</span>生成的一个<span
class="math inline">\(R\)</span>等价类，其中<span
class="math inline">\(x\)</span>称为<span
class="math inline">\([x]_R\)</span>的<strong>生成元</strong>（代表元或典型元）。</p>
<p><strong>定理</strong>  设<span
class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的等价关系，则</p>
<ul>
<li>对任意<span class="math inline">\(x \in A, [x]_R \not=
\varnothing\)</span>；</li>
<li>对任意<span class="math inline">\(x, y \in A\)</span>，如果<span
class="math inline">\(y \in [x]_R\)</span>，则有<span
class="math inline">\([x]_R = [y]_R\)</span>，否则<span
class="math inline">\([x]_R \cap [y]_R = \varnothing\)</span>；</li>
<li><span class="math inline">\(\bigcup_{x \in A}[x]_R =
A\)</span>。</li>
</ul>
<h4 id="商集">商集</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的等价关系，由<span
class="math inline">\(R\)</span>确定的<strong>一切等价类的集合</strong>，称为集合<span
class="math inline">\(A\)</span>上关于<span
class="math inline">\(R\)</span>的<strong>商集</strong>，记为<span
class="math inline">\(A / R\)</span>，即<span class="math inline">\(A /
R = \{[x]_R | x \in A\}\)</span>。</p>
<p><strong>计算商集<span class="math inline">\(A /
R\)</span>的通用过程</strong></p>
<ol type="1">
<li>任选<span class="math inline">\(A\)</span>中一个元素<span
class="math inline">\(a\)</span>，计算<span
class="math inline">\([a]_R\)</span>；</li>
<li>如果<span class="math inline">\([a]_R \not=
A\)</span>，任选一个元素<span class="math inline">\(b \in A -
[a]_R\)</span>，计算<span class="math inline">\([b]_R\)</span>；</li>
<li>如果<span class="math inline">\([a]_R \cup [b]_R \not=
A\)</span>，任选一个元素<span class="math inline">\(c \in A - [a]_R -
[b]_R\)</span>，计算<span class="math inline">\([c]_R\)</span>；</li>
<li>以此类推，直到<span
class="math inline">\(A\)</span>中所有元素都包含在计算出的等价类中。</li>
</ol>
<h3 id="集合的划分">7.2 集合的划分</h3>
<h4 id="定义">定义</h4>
<p>给定一个非空集合<span class="math inline">\(A\)</span>，设有集合<span
class="math inline">\(\pi = \{S_1, S_2, \dots,
S_m\}\)</span>。如果满足：</p>
<ul>
<li><span class="math inline">\(S_i \subseteq A, S_i \not= \varnothing,
i = 1, 2, \dots, m\)</span>；</li>
<li><span class="math inline">\(S_i \cap S_j = \varnothing, i \not= j,
i, j = 1, 2, \dots, m\)</span>；</li>
<li><span class="math inline">\(\bigcup_{i = 1}^m S_i =
A\)</span>。</li>
</ul>
<p>则集合<span class="math inline">\(\pi\)</span>称作集合<span
class="math inline">\(A\)</span>的一个<strong>划分</strong>，而<span
class="math inline">\(S_1, S_2, \dots,
S_m\)</span>叫做这个划分的<strong>块</strong>或<strong>类</strong>。</p>
<h4 id="等价划分">等价划分</h4>
<p><strong>定理</strong>  设<span
class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的等价关系，则<span
class="math inline">\(A\)</span>对<span
class="math inline">\(R\)</span>的商集<span class="math inline">\(A /
R\)</span>是<span
class="math inline">\(A\)</span>的一个划分，称为<strong>由<span
class="math inline">\(R\)</span>所导出的等价划分</strong>。</p>
<h4 id="等价关系导出">等价关系导出</h4>
<p><strong>定理</strong>  给定集合<span
class="math inline">\(A\)</span>的一个划分<span
class="math inline">\(\pi = \{S_1, S_2, \dots,
S_m\}\)</span>，则由该划分确定的关系<span class="math inline">\(R = (S_1
\times S_1) \cup (S_2 \times S_2) \cup \dots \cup (S_m \times
S_m)\)</span>是<span
class="math inline">\(A\)</span>上的等价关系。称该关系<span
class="math inline">\(R\)</span>为<strong>由划分<span
class="math inline">\(\pi\)</span>所导出的等价关系</strong>。</p>
<h3 id="偏序关系定义">7.3 偏序关系定义</h3>
<h4 id="定义-1">定义</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的关系，如果<span
class="math inline">\(R\)</span>是<strong>自反的</strong>、<strong>反对称的</strong>、<strong>传递的</strong>，则称<span
class="math inline">\(R\)</span>为<span
class="math inline">\(A\)</span>上的<strong>偏序关系</strong>，记为<span
class="math inline">\(\leq\)</span>，读作<strong>小于等于</strong>，并将<span
class="math inline">\(\left&lt;a, b\right&gt; \in \leq\)</span>记为<span
class="math inline">\(a \leq b\)</span>。序偶<span
class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>称为<strong>偏序集</strong>。</p>
<blockquote>
<p><span class="math inline">\(\leq\)</span>不是经典的“小于等于”。</p>
</blockquote>
<p>当<span class="math inline">\(a \leq b\)</span>且<span
class="math inline">\(a \not= b\)</span>时，可写作<span
class="math inline">\(a &lt; b\)</span>。</p>
<p><span class="math inline">\(a \leq b\)</span>可写作<span
class="math inline">\(b \geq a\)</span>；<span class="math inline">\(a
&lt; b\)</span>可写作<span class="math inline">\(b &gt; a\)</span>。</p>
<h4 id="可比与覆盖">可比与覆盖</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的偏序关系，<span
class="math inline">\(\forall x, y \in A\)</span>，若：</p>
<ul>
<li><span class="math inline">\(x \leq y\)</span>或<span
class="math inline">\(y \leq x\)</span>，则称<span
class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span><strong>可比</strong>；</li>
<li><span class="math inline">\(x &lt; y\)</span>且不存在<span
class="math inline">\(z \in A\)</span>使得<span class="math inline">\(x
&lt; z &lt; y\)</span>，则称<span
class="math inline">\(y\)</span><strong>覆盖</strong><span
class="math inline">\(x\)</span>。</li>
</ul>
<blockquote>
<p><strong>例</strong>：对于整除关系，有4和6覆盖2：</p>
<p>2可以整除4，2可以整除6，但4不可以整除6。即，对于6，<span
class="math inline">\(2 &lt; 6, 2 &lt; 4 \not&lt; 6\)</span>。</p>
</blockquote>
<h3 id="哈斯图及特殊元素">7.4 哈斯图及特殊元素</h3>
<h4 id="哈斯图">哈斯图</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的偏序关系，使用如下方法对<span
class="math inline">\(R\)</span>的关系图进行简化：</p>
<ul>
<li>取消每个结点的自环；</li>
<li>取消所有由于传递性出现的边。即若<span class="math inline">\(x \to y,
y \to z\)</span>，则去掉<span class="math inline">\(x \to
z\)</span>这条边；</li>
<li>重新排列每条边，使得边的箭头方向全部向上，然后去掉这些箭头。</li>
</ul>
<p>以上步骤可以得到一个包含足够偏序信息的图，这个图称为偏序关系<span
class="math inline">\(R\)</span>的<strong>哈斯图</strong>。</p>
<blockquote>
<p>设<span class="math inline">\(A = \{2, 3, 6, 12, 24,
36\}\)</span>，<span class="math inline">\(\leq\)</span>是<span
class="math inline">\(A\)</span>上的整除关系<span
class="math inline">\(R\)</span>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/04/27/JhCx1I.png" alt="JhCx1I.png" />
<figcaption aria-hidden="true">JhCx1I.png</figcaption>
</figure>
</blockquote>
<h4 id="特殊元素">特殊元素</h4>
<h5 id="最大元和最小元">最大元和最小元</h5>
<p>设<span class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>是偏序集，<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的任何一个子集。若存在元素<span
class="math inline">\(b \in B\)</span>，使得</p>
<ul>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(x \leq b\)</span>，则称<span
class="math inline">\(b\)</span>为<span
class="math inline">\(B\)</span>的<strong>最大元</strong>；</li>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(b \leq x\)</span>，则称<span
class="math inline">\(b\)</span>为<span
class="math inline">\(B\)</span>的<strong>最小元</strong>。</li>
</ul>
<blockquote>
<p>如果不可比，则不存在最大元、最小元。</p>
</blockquote>
<h5 id="极大元和极小元">极大元和极小元</h5>
<p>设<span class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>是偏序集，<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的任何一个子集。若存在元素<span
class="math inline">\(b \in B\)</span>，使得</p>
<ul>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(b \leq x \Rightarrow x = b\)</span>，则称<span
class="math inline">\(b\)</span>为<span
class="math inline">\(B\)</span>的<strong>极大元</strong>；</li>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(x \leq b \Rightarrow x = b\)</span>，则称<span
class="math inline">\(b\)</span>为<span
class="math inline">\(B\)</span>的<strong>极小元</strong>。</li>
</ul>
<blockquote>
<p>如果不可比，则都是极大元、极小元。</p>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li><p><span
class="math inline">\(B\)</span>的最大元、最小元、极大元和极小元如果存在，一定在<span
class="math inline">\(B\)</span>中；</p></li>
<li><p><span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的最大元<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(B\)</span>中所有的元素都比<span
class="math inline">\(b\)</span>小；</p>
<p><span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的最小元<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(B\)</span>中所有的元素都比<span
class="math inline">\(b\)</span>大；</p>
<p><span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的极大元<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(B\)</span>中没有比<span
class="math inline">\(b\)</span>大的元素；</p>
<p><span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的极小元<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(B\)</span>中没有比<span
class="math inline">\(b\)</span>小的元素；</p></li>
</ul>
<h5 id="上界和上确界">上界和上确界</h5>
<p>设<span class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>是偏序集，<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的任何一个子集。若存在元素<span
class="math inline">\(a \in A\)</span>，使得</p>
<ul>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(x \leq a\)</span>，则称<span
class="math inline">\(a\)</span>为<span
class="math inline">\(B\)</span>的<strong>上界</strong>；</li>
<li>若元素<span class="math inline">\(a&#39; \in A\)</span>是<span
class="math inline">\(B\)</span>的上界，元素<span
class="math inline">\(a \in A\)</span>是<span
class="math inline">\(B\)</span>的任何一个上界，若均有<span
class="math inline">\(a&#39; \leq a\)</span>，则称<span
class="math inline">\(a\)</span>为<span
class="math inline">\(B\)</span>的<strong>最小上界</strong>或<strong>上确界</strong>。</li>
</ul>
<h5 id="下界和下确界">下界和下确界</h5>
<p>设<span class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>是偏序集，<span
class="math inline">\(B\)</span>是<span
class="math inline">\(A\)</span>的任何一个子集。若存在元素<span
class="math inline">\(a \in A\)</span>，使得</p>
<ul>
<li>对任意<span class="math inline">\(x \in B\)</span>，都有<span
class="math inline">\(a \leq x\)</span>，则称<span
class="math inline">\(a\)</span>为<span
class="math inline">\(B\)</span>的<strong>下界</strong>；</li>
<li>若元素<span class="math inline">\(a&#39; \in A\)</span>是<span
class="math inline">\(B\)</span>的上界，元素<span
class="math inline">\(a \in A\)</span>是<span
class="math inline">\(B\)</span>的任何一个上界，若均有<span
class="math inline">\(a \leq a&#39;\)</span>，则称<span
class="math inline">\(a\)</span>为<span
class="math inline">\(B\)</span>的<strong>最大下界</strong>或<strong>下确界</strong>。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p>子集<span
class="math inline">\(B\)</span>的上、下界和上、下确界可在集合<span
class="math inline">\(A\)</span>中寻找；</p></li>
<li><p>子集<span
class="math inline">\(B\)</span>的上、下界不一定存在，如果存在可能多个；</p></li>
<li><p>子集<span
class="math inline">\(B\)</span>的上、下确界不一定存在，如果存在一定唯一；</p></li>
<li><p>若子集<span
class="math inline">\(B\)</span>有上（下）确界，则一定有上（下）界。反之不然。</p>
<blockquote>
<p>因为上（下）界中的元素不一定都可比。</p>
</blockquote></li>
</ul>
<h5 id="总结">总结</h5>
<ul>
<li>若<span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的最大元，则<span
class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的极大元、上界之一、上确界；</li>
<li>若<span class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的最小元，则<span
class="math inline">\(b\)</span>是<span
class="math inline">\(B\)</span>的极小元、下界之一、下确界；</li>
<li>若<span class="math inline">\(a\)</span>是<span
class="math inline">\(B\)</span>的上确界，且<span
class="math inline">\(a \in B\)</span>，则<span
class="math inline">\(a\)</span>是<span
class="math inline">\(B\)</span>的最大元；</li>
<li>若<span class="math inline">\(a\)</span>是<span
class="math inline">\(B\)</span>的下确界，且<span
class="math inline">\(a \in B\)</span>，则<span
class="math inline">\(a\)</span>是<span
class="math inline">\(B\)</span>的最小元；</li>
<li>集合<span
class="math inline">\(B\)</span>的最大（小）元，上（下）确界若存在，则唯一；</li>
<li>集合<span
class="math inline">\(B\)</span>若无最大（小）元，必然存在多个极大（小）元。</li>
</ul>
<h3 id="其它次序关系">7.5 其它次序关系</h3>
<h4 id="拟序关系">拟序关系</h4>
<p>设<span class="math inline">\(R\)</span>是非空集合<span
class="math inline">\(A\)</span>上的关系，如果<span
class="math inline">\(R\)</span>是<strong>反自反的</strong>和<strong>传递的</strong>，则称<span
class="math inline">\(R\)</span>为<span
class="math inline">\(A\)</span>上的<strong>拟序关系</strong>，记为<span
class="math inline">\(&lt;\)</span>，读作<strong>小于</strong>，并将<span
class="math inline">\(\left&lt;a, b\right&gt; \in &lt;\)</span>记为<span
class="math inline">\(a &lt; b\)</span>。序偶<span
class="math inline">\(\left&lt;A,
&lt;\right&gt;\)</span>称为<strong>拟序集</strong>。</p>
<p><strong>定理</strong>  设<span
class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的拟序关系，则<span
class="math inline">\(R\)</span>是<strong>反对称的</strong>。</p>
<blockquote>
<p>若<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的偏序关系，则<span
class="math inline">\(R - I_A\)</span>是<span
class="math inline">\(A\)</span>上的拟序关系；</p>
<p>若<span class="math inline">\(S\)</span>是集合<span
class="math inline">\(A\)</span>上的拟序关系，则<span
class="math inline">\(S + I_A\)</span>是<span
class="math inline">\(A\)</span>上的偏序关系。</p>
</blockquote>
<h4 id="全序关系">全序关系</h4>
<p>设<span class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>是一个<strong>偏序关系</strong>，若对任意<span
class="math inline">\(x, y \in A\)</span>，<span
class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>
都是<strong>可比的</strong>，则称关系<span
class="math inline">\(\leq\)</span>为<strong>全序关系</strong>或<strong>线序关系</strong>。称<span
class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>为<strong>全序集</strong>，或<strong>线序集</strong>，或<strong>链</strong>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/04/27/JhmmvQ.png" alt="JhmmvQ.png" />
<figcaption aria-hidden="true">JhmmvQ.png</figcaption>
</figure>
<p>全序关系的哈斯图将集合中的元素排成一条线，像一条链子，这充分体现了全序集可以称作线序集或链的原因。</p>
<h4 id="良序关系">良序关系</h4>
<p>设<span class="math inline">\(\left&lt;A, \leq\right&gt;\)</span>
是<strong>全序集</strong>，若<span
class="math inline">\(A\)</span>的任何一个非空子集都有<strong>最小元素</strong>，则称<span
class="math inline">\(\leq\)</span>为<strong>良序关系</strong>，此时<span
class="math inline">\(\left&lt;A,
\leq\right&gt;\)</span>称为<strong>良序集</strong>。</p>
<p>良序关系一定是<strong>全序关系</strong>，而<strong>有限全序集</strong>一定是良序集。</p>
<h4 id="总结-1">总结</h4>
<p>偏序关系、全序关系和良序关系之间的关系如下图：</p>
<figure>
<img src="https://s1.ax1x.com/2020/04/27/Jhmy8O.png" alt="Jhmy8O.png" />
<figcaption aria-hidden="true">Jhmy8O.png</figcaption>
</figure>
<h2 id="第八章-函数">第八章 函数</h2>
<h3 id="函数基本定义">8.1 函数基本定义</h3>
<h4 id="定义-2">定义</h4>
<p>设<span class="math inline">\(f\)</span>是集合<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的关系，如果对每个<span
class="math inline">\(x \in A\)</span>，都存在唯一的<span
class="math inline">\(y \in B\)</span>，使得<span
class="math inline">\(\left&lt;x, y\right&gt; \in
f\)</span>，则称关系<span class="math inline">\(f\)</span>为<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>函数</strong>或<strong>映射</strong>，记为<span
class="math inline">\(f: A \to B\)</span>。<span
class="math inline">\(A\)</span>为函数<span
class="math inline">\(f\)</span>的<strong>定义域</strong>，记为<span
class="math inline">\(\operatorname{dom}f = A\)</span>；<span
class="math inline">\(f(A)\)</span>为函数<span
class="math inline">\(f\)</span>的<strong>值域</strong>，记为<span
class="math inline">\(\operatorname{ran}f\)</span>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/05/08/YnZoAs.png" alt="YnZoAs.png" />
<figcaption aria-hidden="true">YnZoAs.png</figcaption>
</figure>
<p>当<span class="math inline">\(\left&lt;x, y\right&gt; \in
f\)</span>时，通常记为<span class="math inline">\(y =
f(x)\)</span>。这时称<span class="math inline">\(x\)</span>为函数<span
class="math inline">\(f\)</span>的<strong>自变量</strong>（原像），<span
class="math inline">\(y\)</span>为<span
class="math inline">\(x\)</span>在<span
class="math inline">\(f\)</span>下的<strong>函数值</strong>（像）。注意区分<span
class="math inline">\(f\)</span>和<span
class="math inline">\(f(x)\)</span>，二者是不同的。</p>
<p>如果关系<span
class="math inline">\(f\)</span>具备下列两种情况之一，那么<span
class="math inline">\(f\)</span>就不是函数：</p>
<ul>
<li>存在元素<span class="math inline">\(a \in A\)</span>，在<span
class="math inline">\(B\)</span>中没有像；</li>
<li>存在元素<span class="math inline">\(a \in
A\)</span>，有两个及两个以上的像。</li>
</ul>
<p>所有从<span class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的一切函数构成的集合记为<span
class="math inline">\(B^A\)</span>： <span class="math display">\[
B^A = \{f|f: A \to B\}
\]</span></p>
<h4 id="函数的数量">函数的数量</h4>
<p>设函数<span class="math inline">\(f: A \to B, |A| = m, |B| =
n\)</span>，对<span
class="math inline">\(A\)</span>中的每个元素而言，其序偶的第二元素都有<span
class="math inline">\(n\)</span>种可能的选择，因而总共有<span
class="math inline">\(n^m\)</span>种选法，也就是有<span
class="math inline">\(n^m\)</span>个不同的函数。</p>
<h4 id="关系与函数的差别">关系与函数的差别</h4>
<p>当<span class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>都是有限集合时，函数和一般关系具有如下差别：</p>
<ul>
<li>关系和函数的数量不同：从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的不同关系有<span
class="math inline">\(2^{|A| \times |B|}\)</span>个，从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的不同函数却仅有<span
class="math inline">\(|B|^{|A|}\)</span>个；</li>
<li>关系和函数的基数不同：每一个关系的基数可以从零一直到<span
class="math inline">\(|A| \times |B|\)</span>，每一个函数的基数都为<span
class="math inline">\(|A|\)</span>个；</li>
<li>关系和函数的第一元素存在差别：关系的第一个元素可以相同，函数的第一元素一定是互不相同的。</li>
</ul>
<h3 id="函数的类型">8.2 函数的类型</h3>
<h4 id="函数的类型-1">函数的类型</h4>
<p>设<span class="math inline">\(f\)</span>是从集合<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的函数。</p>
<ul>
<li>对任意<span class="math inline">\(x_1, x_2 \in A\)</span>，如果<span
class="math inline">\(x_1 \not= x_2\)</span>，都有<span
class="math inline">\(f(x_1) \not= f(x_2)\)</span>，则称<span
class="math inline">\(f\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>单射</strong>；</li>
<li>如果<span class="math inline">\(\operatorname{ran}f =
B\)</span>，则称<span class="math inline">\(f\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>满射</strong>；</li>
<li>如果<span
class="math inline">\(f\)</span>既是单射又是满射，则称<span
class="math inline">\(f\)</span>为从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的<strong>双射</strong>。</li>
</ul>
<p><strong>必要条件</strong></p>
<p>若<span class="math inline">\(f\)</span>是从有限集<span
class="math inline">\(A\)</span>到有限集<span
class="math inline">\(B\)</span>的函数，则有</p>
<ul>
<li><span
class="math inline">\(f\)</span>是<strong>单射</strong>的必要条件为<span
class="math inline">\(|A| \leq |B|\)</span>；</li>
<li><span
class="math inline">\(f\)</span>是<strong>满射</strong>的必要条件为<span
class="math inline">\(|A| \geq |B|\)</span>；</li>
<li><span
class="math inline">\(f\)</span>是<strong>双射</strong>的必要条件为<span
class="math inline">\(|A| = |B|\)</span>。</li>
</ul>
<p><strong>函数类型的数学化描述</strong></p>
<p><span class="math inline">\(f: A \to
B\)</span>是单射，当且仅当对<span class="math inline">\(\forall x_1, x_2
\in A\)</span>，若<span class="math inline">\(x_1 \not=
x_2\)</span>，则<span class="math inline">\(f(x_1) \not=
f(x_2)\)</span>；</p>
<p><span class="math inline">\(f: A \to
B\)</span>是满射，当且仅当对<span class="math inline">\(\forall y \in
B\)</span>，一定存在<span class="math inline">\(x \in
A\)</span>，使得<span class="math inline">\(f(x) = y\)</span>；</p>
<p><span class="math inline">\(f: A \to
B\)</span>是双射，当且仅当满足以上两点。</p>
<h4 id="典型自然映射">典型（自然）映射</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span
class="math inline">\(A\)</span>上的一个等价关系，<span
class="math inline">\(g: A \to A/R\)</span>称为<span
class="math inline">\(A\)</span>对商集<span
class="math inline">\(A/R\)</span>的<strong>典型（自然）映射</strong>，其定义为<span
class="math inline">\(g(a) = [a]_R, a\ in A\)</span>。它是一个满射。</p>
<h4 id="函数类型证明">函数类型证明</h4>
<p>根据数学化描述证明。</p>
<p><em>证明单射可以考虑反证。例如：对任意<span
class="math inline">\(x_1, x_2 \in A, x_1 \not= x_2\)</span>，假设<span
class="math inline">\(f(x_1) = f(x_2)\)</span></em>。</p>
<p><em>证明满射可以考虑包含关系。例如：有<span
class="math inline">\(f(A) \subset B\)</span>，证明<span
class="math inline">\(|f(A)| = |B|\)</span>。</em></p>
<h3 id="函数的运算">8.3 函数的运算</h3>
<h4 id="函数的复合">函数的复合</h4>
<p>设<span class="math inline">\(f: A \to B, g: B \to
C\)</span>是两个函数，则<span class="math inline">\(f\)</span>与<span
class="math inline">\(g\)</span>的复合关系<span class="math inline">\(f
\circ g = \{\left&lt;x, z\right&gt; | x \in A, z \in C, \exist y \in B,
使得y = f(x)且z = g(y)\}\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的函数，称为函数<span
class="math inline">\(f\)</span>与<span
class="math inline">\(g\)</span>的<strong>复合函数</strong>，记为<span
class="math inline">\(f \circ g: A \to C\)</span>。</p>
<p>函数<span class="math inline">\(f\)</span>和<span
class="math inline">\(g\)</span>可以复合的前提条件是<span
class="math inline">\(\operatorname{ran}f \subseteq
\operatorname{dom}g\)</span>；</p>
<p><span class="math inline">\(\operatorname{dom}(f \circ g) =
\operatorname{dom}f, \operatorname{ran}(f \circ g) =
\operatorname{ran}g\)</span>；</p>
<p>对任意<span class="math inline">\(x \in A\)</span>，有<span
class="math inline">\(f\circ g(x) = g(f(x))\)</span>；</p>
<p><span class="math inline">\(I_A \circ f = f \circ I_B =
f\)</span>.</p>
<h4 id="复合运算的保守性">复合运算的保守性</h4>
<p>设<span class="math inline">\(f\)</span>和<span
class="math inline">\(g\)</span>分别是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>和从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的函数，则</p>
<ul>
<li>设<span class="math inline">\(f, g\)</span>是满射，则<span
class="math inline">\(f \circ g\)</span>也是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的满射；</li>
<li>设<span class="math inline">\(f, g\)</span>是单射，则<span
class="math inline">\(f \circ g\)</span>也是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的单射；</li>
<li>设<span class="math inline">\(f, g\)</span>是双射，则<span
class="math inline">\(f \circ g\)</span>也是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的双射。</li>
</ul>
<blockquote>
<p>如<span class="math inline">\(f \circ g\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的满射，则<span
class="math inline">\(g\)</span>是从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的满射；</p>
<p>如<span class="math inline">\(f \circ g\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的单射，则<span
class="math inline">\(f\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的单射；</p>
<p>如<span class="math inline">\(f \circ g\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>的双射，则<span
class="math inline">\(f\)</span>是从<span
class="math inline">\(A\)</span>到<span
class="math inline">\(B\)</span>的单射，<span
class="math inline">\(g\)</span>是从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(C\)</span>的满射。</p>
</blockquote>
<h4 id="函数的逆">函数的逆</h4>
<p>设<span class="math inline">\(f: A \to B\)</span>是函数，如果<span
class="math inline">\(f^{-1} = \{\left&lt;y, x\right&gt; | x \in A, y\
in B, y = f(x)\}\)</span>是从<span
class="math inline">\(B\)</span>到<span
class="math inline">\(A\)</span>的函数，则称<span
class="math inline">\(f^{-1}: B \to A\)</span>为函数<span
class="math inline">\(f\)</span>的<strong>逆函数</strong>。</p>
<p>函数<span class="math inline">\(f^{-1}\)</span>存在，当且仅当<span
class="math inline">\(f\)</span>是双射，此时<span
class="math inline">\(f^{-1}\)</span>也是双射。</p>
<p><span class="math inline">\(f \circ f^{-1} = I_A, f^{-1} \circ f =
I_B\)</span>.</p>
<h2 id="第九章-图论基础">第九章 图论基础</h2>
<h3 id="图的引入">9.1 图的引入</h3>
<h4 id="不同类型的图">不同类型的图</h4>
<figure>
<img src="https://s1.ax1x.com/2020/05/11/YJ7CnA.png" alt="YJ7CnA.png" />
<figcaption aria-hidden="true">YJ7CnA.png</figcaption>
</figure>
<figure>
<img src="https://s1.ax1x.com/2020/05/11/YJ7kAP.png" alt="YJ7kAP.png" />
<figcaption aria-hidden="true">YJ7kAP.png</figcaption>
</figure>
<h4 id="无序对和无序积">无序对和无序积</h4>
<p>设<span class="math inline">\(A, B\)</span>为任意集合，称集合<span
class="math inline">\(A\&amp;B = \{(a, b) | a \in A, b \in
B\}\)</span>为<span class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>的<strong>无序积</strong>，<span
class="math inline">\((a, b)\)</span>称为<strong>无序对</strong>。</p>
<blockquote>
<p>与序偶不同，对<span class="math inline">\(\forall a, b, \ (a, b) =
(b, a)\)</span>。</p>
</blockquote>
<h4 id="图的定义">图的定义</h4>
<p>一个<strong>图</strong>是一个序偶<span
class="math inline">\(\left&lt;V, E\right&gt;\)</span>，记为<span
class="math inline">\(G = \left&lt;V, E\right&gt;\)</span>，其中：</p>
<ul>
<li><span class="math inline">\(V = \{v_1, v_2, \dots,
v_n\}\)</span>是有限非空集合，<span
class="math inline">\(v_i\)</span>称为<strong>结点</strong>，<span
class="math inline">\(V\)</span>称为<strong>结点集</strong>。</li>
<li><span
class="math inline">\(E\)</span>是有限集合，称为<strong>边集</strong>。<span
class="math inline">\(E\)</span>中的每个元素都有<span
class="math inline">\(V\)</span>中的结点对与之对应，称之为<strong>边</strong>。</li>
</ul>
<p>与边对应的结点对既可以是无序的，也可以是有序的。</p>
<p>若边<span class="math inline">\(e\)</span>与无序结点对<span
class="math inline">\((u, v)\)</span>相对应，则称<span
class="math inline">\(e\)</span>为<strong>无向边</strong>，记为<span
class="math inline">\(e = (u, v) = (v, u)\)</span>，这时称<span
class="math inline">\(u, v\)</span>是边<span
class="math inline">\(e\)</span>的两个<strong>端点</strong>。</p>
<p>若边<span class="math inline">\(e\)</span>与有序结点对<span
class="math inline">\(\left&lt;u, v\right&gt;\)</span>相对应，则称<span
class="math inline">\(e\)</span>为<strong>有向边</strong>或<strong>弧</strong>，记为<span
class="math inline">\(e = \left&lt;u, v\right&gt;\)</span>，这时称<span
class="math inline">\(u\)</span>为<span
class="math inline">\(e\)</span>的<strong>始点</strong>或<strong>弧尾</strong>，<span
class="math inline">\(v\)</span>为<span
class="math inline">\(e\)</span>的<strong>终点</strong>或<strong>弧头</strong>，统称为<span
class="math inline">\(e\)</span>的<strong>端点</strong>。</p>
<h3 id="图的表示">9.2 图的表示</h3>
<h4 id="集合表示和图形表示">集合表示和图形表示</h4>
<p><strong>图的集合表示</strong>：对于一个图<span
class="math inline">\(G\)</span>，如果将其记为<span
class="math inline">\(G = \left&lt;V, E\right&gt;\)</span>，并写出<span
class="math inline">\(V\)</span>和<span
class="math inline">\(E\)</span>的集合表示，这称为<strong>图的集合表示</strong>。</p>
<p><strong>图的图形表示</strong>：用小圆圈表示<span
class="math inline">\(V\)</span>中的结点，用由<span
class="math inline">\(u\)</span>指向<span
class="math inline">\(v\)</span>的有向线段或曲线表示有向边<span
class="math inline">\(\left&lt;u,
v\right&gt;\)</span>，无向线段或曲线表示无向边<span
class="math inline">\((u, v)\)</span>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/05/11/YJbnwn.png" alt="YJbnwn.png" />
<figcaption aria-hidden="true">YJbnwn.png</figcaption>
</figure>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>设图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，其中<span class="math inline">\(V = \{v_1, v_2,
\dots, v_n\}\)</span>，并假定结点已经有了从<span
class="math inline">\(v_1\)</span>到<span
class="math inline">\(v_n\)</span>的次序，则<span
class="math inline">\(n\)</span>阶方阵<span class="math inline">\(A_G =
(a_{ij})_{n \times n}\)</span>称为<span
class="math inline">\(G\)</span>的<strong>邻接矩阵</strong>，其中<span
class="math inline">\(a_{ij} = \begin{cases}1 &amp; \left&lt;v_i,
v_j\right&gt; \in E 或 (v_i, v_j) \in E \\ 0 &amp; 否则
\end{cases}\)</span>。</p>
<h4 id="邻接点与邻接边">邻接点与邻接边</h4>
<p>在图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，若两个结点<span
class="math inline">\(v_i\)</span>和<span
class="math inline">\(v_j\)</span>是边<span
class="math inline">\(e\)</span>的端点，则称<span
class="math inline">\(v_i\)</span>与<span
class="math inline">\(v_j\)</span>互为<strong>邻接点</strong>，否则<span
class="math inline">\(v_i\)</span>与<span
class="math inline">\(v_j\)</span>称为<strong>不邻接的</strong>；具有公共结点的两条边称为<strong>邻接边</strong>；两个端点相同的边称为<strong>环</strong>或<strong>自回路</strong>；图中不与任何结点相邻接的结点称为<strong>孤立结点</strong>。</p>
<h4 id="一些简单的特殊图">一些简单的特殊图</h4>
<ul>
<li><strong>零图</strong>：仅由孤立结点组成的图；</li>
<li><strong>平凡图</strong>：仅含一个结点的零图；</li>
<li><strong><span class="math inline">\((n,
m)\)</span>图</strong>：含有<span
class="math inline">\(n\)</span>个结点<span
class="math inline">\(m\)</span>条边的图。</li>
</ul>
<p>环的存在与否不会导致图论定理的重大变化，很多场合下都会被忽略；</p>
<p>零图没有任何边，邻接矩阵为全0；</p>
<p><span class="math inline">\((n,
m)\)</span>图的各边如何分布，不说明则不清楚。</p>
<h3 id="图的分类">9.3 图的分类</h3>
<h4 id="按边有无方向分类">按边有无方向分类</h4>
<p>每条边都是无向边的图称为<strong>无向图</strong>；</p>
<p>每条边都是有向边的图称为<strong>有向图</strong>；</p>
<p>有些边是无向边，而另一些边是有向边的图称为<strong>混合图</strong>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/05/11/YJLC28.png" alt="YJLC28.png" />
<figcaption aria-hidden="true">YJLC28.png</figcaption>
</figure>
<h4 id="按有无平行边分类">按有无平行边分类</h4>
<p>在有向图中，两结点间（包括结点自身间）若有同始点和同终点的几条边，则这几条边称为<strong>平行边</strong>；</p>
<p>在无向图中，两结点间（包括结点自身间）若有几条边，则这几条边称为<strong>平行边</strong>。</p>
<p>两结点<span class="math inline">\(a,
b\)</span>间相互平行的边的条数称为边<span class="math inline">\((a,
b)\)</span>或<span class="math inline">\(\left&lt;a,
b\right&gt;\)</span>的<strong>重数</strong>。</p>
<p>含有平行边的图称为<strong>多重图</strong>；</p>
<p>非多重图称为<strong>线图</strong>；</p>
<p>无环的线图称为<strong>简单图</strong>。</p>
<h4 id="按有无权值分类">按有无权值分类</h4>
<p><strong>赋权图</strong><span
class="math inline">\(G\)</span>是一个三重组<span
class="math inline">\(\left&lt;V, E, g\right&gt;\)</span>或四重组<span
class="math inline">\(\left&lt;V, E, f, g\right&gt;\)</span>，其中<span
class="math inline">\(V\)</span>是结点集合，<span
class="math inline">\(E\)</span>是边的集合，<span
class="math inline">\(f\)</span>是从<span
class="math inline">\(V\)</span>到非负实数集合的函数（即结点的权值函数），<span
class="math inline">\(g\)</span>是从<span
class="math inline">\(E\)</span>到非负实数集合的函数（即边的权值函数）。</p>
<p>相应的，边或结点均无权值的图称为<strong>无权图</strong>。</p>
<h3 id="子图和补图">9.4 子图和补图</h3>
<h4 id="各类子图">各类子图</h4>
<p>设有图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>和图<span class="math inline">\(G_1 = \left&lt;V_1,
E_1\right&gt;\)</span>。</p>
<ul>
<li><p>若<span class="math inline">\(V_1 \subseteq V\)</span>，<span
class="math inline">\(E_1 \subseteq E\)</span>，则称<span
class="math inline">\(G_1\)</span>是<span
class="math inline">\(G\)</span>的<strong>子图</strong>，记为<span
class="math inline">\(G_1 \subseteq G\)</span>。</p></li>
<li><p>若<span class="math inline">\(G_1 \subseteq G\)</span>，且<span
class="math inline">\(G_1 \not= G\)</span>（即<span
class="math inline">\(V_1 \subset V\)</span>或<span
class="math inline">\(E_1 \subset E\)</span>），则称<span
class="math inline">\(G_1\)</span>是<span
class="math inline">\(G\)</span>的<strong>真子图</strong>，记为<span
class="math inline">\(G_1 \subset G\)</span>。</p></li>
<li><p>若<span class="math inline">\(V_1 = V, E_1 \subseteq
E\)</span>，则称<span class="math inline">\(G_1\)</span>是<span
class="math inline">\(G\)</span>的<strong>生成子图</strong>。</p>
<blockquote>
<p><em>生成子图：相对于原图，全部的结点都在。</em></p>
</blockquote></li>
<li><p>设<span class="math inline">\(V_2 \subseteq V\)</span>且<span
class="math inline">\(V_2 \not= \varnothing\)</span>，以<span
class="math inline">\(V_2\)</span>为结点集，以两个端点均在<span
class="math inline">\(V_2\)</span>中的边的全体为边集的<span
class="math inline">\(G\)</span>的子图，称为<span
class="math inline">\(V_2\)</span>导出的<span
class="math inline">\(G\)</span>的子图，简称<span
class="math inline">\(V_2\)</span>的<strong>导出子图</strong>。</p>
<blockquote>
<p><em>导出子图：相对于原图，只要结点还在，其对应的全部的边都在。</em></p>
</blockquote></li>
</ul>
<figure>
<img src="https://s1.ax1x.com/2020/05/15/YrCH2t.png" alt="YrCH2t.png" />
<figcaption aria-hidden="true">YrCH2t.png</figcaption>
</figure>
<h4 id="完全图">完全图</h4>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为一个具有<span
class="math inline">\(n\)</span>个结点的无向简单图，如果<span
class="math inline">\(G\)</span>中任意两个结点间都有边相连，则称<span
class="math inline">\(G\)</span>为<strong>无向完全图</strong>，简称<span
class="math inline">\(G\)</span>为<strong>完全图</strong>，记为<span
class="math inline">\(K_n\)</span>。</p>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为一个具有<span
class="math inline">\(n\)</span>个结点的有向简单图，如果<span
class="math inline">\(G\)</span>中任意两个结点间都有两条方向相反的有向边相连，则称<span
class="math inline">\(G\)</span>为<strong>有向完全图</strong>，在不发生误解的情况下，也记为<span
class="math inline">\(K_n\)</span>。</p>
<ul>
<li>完全图的邻接矩阵除主对角线上的元素为0外，其余元素均为1；</li>
<li>无向完全图<span class="math inline">\(K_n\)</span>的边数为<span
class="math inline">\(C_n^2 = \frac12 n(n-1)\)</span>；</li>
<li>有向完全图<span class="math inline">\(K_n\)</span>的边数为<span
class="math inline">\(P_n^2 = n(n-1)\)</span>.</li>
</ul>
<h4 id="补图">补图</h4>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为简单图，<span class="math inline">\(G&#39; =
\left&lt;V, E_1\right&gt;\)</span>为完全图，则称<span
class="math inline">\(G_1 = \left&lt;V, E_1 -
E\right&gt;\)</span>为<span
class="math inline">\(G\)</span>的<strong>补图</strong>，记为<span
class="math inline">\(\overline G\)</span>。</p>
<ul>
<li>补图<span class="math inline">\(\overline
G\)</span>就是从完全图中删除图<span
class="math inline">\(G\)</span>中的边；</li>
<li>补图<span class="math inline">\(\overline G\)</span>就是以<span
class="math inline">\(V\)</span>为结点集，以所有能使<span
class="math inline">\(G\)</span>成为完全图<span
class="math inline">\(K_n\)</span>的添加边组成的集合为边集的图；</li>
<li>图<span class="math inline">\(G\)</span>和它的补图<span
class="math inline">\(\overline G\)</span>有相同的结点，两个结点在<span
class="math inline">\(\overline G\)</span>里相邻，当且仅当它们在<span
class="math inline">\(G\)</span>里不相邻。</li>
</ul>
<p><strong>邻接矩阵求补图的方法</strong></p>
<p>若设简单图<span class="math inline">\(G\)</span>的邻接矩阵<span
class="math inline">\(A = (a_{ij})_{n \times
n}\)</span>，则它的补图<span class="math inline">\(\overline
G\)</span>的邻接矩阵<span class="math inline">\(\overline A =
(\overline{a_{ij}})_{n \times n}\)</span>为： <span
class="math display">\[
\overline{a_{i,j}} = \begin{cases}
1 - a_{ij} &amp; i \not= j \\
0 &amp; i = j
\end{cases}, (i, j = 1, 2, 3, \dots, n)
\]</span></p>
<h3 id="握手定理">9.5 握手定理</h3>
<h4 id="结点的度数">结点的度数</h4>
<p>图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中以结点<span class="math inline">\(v \in
V\)</span>为端点的次数之和称为结点<span
class="math inline">\(v\)</span>的<strong>度数</strong>或<strong>度</strong>，记为<span
class="math inline">\(\deg(v)\)</span>。显然，有环时则需计算两次。</p>
<p>有向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中以结点<span
class="math inline">\(v\)</span>为始点的次数称为<span
class="math inline">\(v\)</span>的<strong>出度</strong>，记为<span
class="math inline">\(\deg^+(v)\)</span>；以结点<span
class="math inline">\(v\)</span>为终点的次数称为<span
class="math inline">\(v\)</span>的<strong>入度</strong>，记为<span
class="math inline">\(\deg^-(v)\)</span>。显然，<span
class="math inline">\(\deg(v) = \deg^+(v) + \deg^-(v)\)</span>。</p>
<p>图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，称<span class="math inline">\(\Delta(G) =
\max\{\deg(v) | v \in V\}\)</span>为<span
class="math inline">\(G\)</span>的<strong>最大度</strong>，<span
class="math inline">\(\delta(G) = \min\{\deg(v) | v \in
V\}\)</span>称为<span
class="math inline">\(G\)</span>的<strong>最小度</strong>。</p>
<p>有向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，称<span class="math inline">\(\Delta^+(G) =
\max\{\deg^+(v) | v \in V\}\)</span>为<span
class="math inline">\(G\)</span>的<strong>最大出度</strong>，<span
class="math inline">\(\delta^+(G) = \min\{\deg^+(v) | v \in
V\}\)</span>称为<span
class="math inline">\(G\)</span>的<strong>最小出度</strong>；<span
class="math inline">\(\Delta^-(G) = \max\{\deg^-(v) | v \in
V\}\)</span>为<span
class="math inline">\(G\)</span>的<strong>最大入度</strong>，<span
class="math inline">\(\delta^-(G) = \min\{\deg^-(v) | v \in
V\}\)</span>称为<span
class="math inline">\(G\)</span>的<strong>最小入度</strong>。</p>
<p>设图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，<span class="math inline">\(V = \{v_1, v_2, \dots,
v_n\}\)</span>的邻接矩阵为 <span class="math display">\[
A = \begin{pmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{pmatrix}
\]</span></p>
<ul>
<li>若<span class="math inline">\(G\)</span>是无向图，则结点<span
class="math inline">\(v_i\)</span>的度数<span
class="math inline">\(\deg(v_i) = \sum_{k = 1}^n a_{ik} +
a_{ii}\)</span>或<span class="math inline">\(\deg(v_i) = \sum_{k = 1}^n
a_{ki} + a_{ii}\)</span>；</li>
<li>若<span class="math inline">\(G\)</span>是有向图，则结点<span
class="math inline">\(v_i\)</span>的出度<span
class="math inline">\(\deg^+(v_i) = \sum_{k = 1}^n
a_{ik}\)</span>，入度<span class="math inline">\(\deg^-(v_i) = \sum_{k =
1}^n a_{ki}\)</span>.</li>
</ul>
<h4 id="握手定理-1">握手定理</h4>
<p><strong>定理</strong>  图中结点度数的总和等于边数的二倍，即设图<span
class="math inline">\(G = \left&lt;V, E\right&gt;\)</span>，则有 <span
class="math display">\[
\sum_{v \in V} \deg(v) = 2|E|
\]</span> <strong>推论</strong>  图中度数为奇数的结点个数为偶数。</p>
<p>常称度数为奇数的结点为<strong>奇度数结点</strong>，度数为偶数的结点为<strong>偶度数结点</strong>。</p>
<p><strong>定理</strong>  有向图中各结点的出度之和等于各结点的入度之和，等于边数，即设有向图<span
class="math inline">\(G = \left&lt;V, E\right&gt;\)</span>，则有 <span
class="math display">\[
\sum_{v \in V} \deg^+(v) = \sum_{v \in V} \deg^-(v) = |E|
\]</span></p>
<p>设<span class="math inline">\(V = \{v_1, v_2, \dots,
v_n\}\)</span>为图<span
class="math inline">\(G\)</span>的结点集，称<span
class="math inline">\((\deg(v_1), \deg(v_2), \dots,
\deg(v_n))\)</span>为<span
class="math inline">\(G\)</span>的<strong>度数序列</strong>。若<span
class="math inline">\(G\)</span>为有向图，还可分别定义<strong>出度序列</strong>和<strong>入度序列</strong>。</p>
<h3 id="图的同构">9.6 图的同构</h3>
<h4 id="引言">引言</h4>
<blockquote>
<p>即，两个图本质上是同一个图。</p>
</blockquote>
<h4 id="定义-3">定义</h4>
<p>设两个图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>和<span class="math inline">\(G&#39; =
\left&lt;V&#39;, E&#39;\right&gt;\)</span>，如果存在双射函数<span
class="math inline">\(g: V \to V&#39;\)</span>，使得对于任意的<span
class="math inline">\(e = (v_i, v_j)\)</span>（或者<span
class="math inline">\(\left&lt;v_i, v_j\right&gt;\)</span>）<span
class="math inline">\(\in E\)</span>当且仅当<span
class="math inline">\(e&#39; = (g(v_i), g(v_j))\)</span>（或者<span
class="math inline">\(\left&lt;g(v_i), g(v_j)\right&gt;\)</span>）<span
class="math inline">\(\in E&#39;\)</span>，并且<span
class="math inline">\(e\)</span>与<span
class="math inline">\(e&#39;\)</span>的重数相同，则称<span
class="math inline">\(G\)</span>与<span
class="math inline">\(G&#39;\)</span><strong>同构</strong>，记为<span
class="math inline">\(G \cong G&#39;\)</span>。</p>
<blockquote>
<p>形象地说，若图的结点可以任意挪动位置，而边是完全弹性的，只要在不拉断的条件下，一个图可以变形为另一个图，那么这两个图是同构的。</p>
</blockquote>
<h4 id="必要条件">必要条件</h4>
<ul>
<li>结点数目相同</li>
<li>边数相同</li>
<li>度数相同的结点数相同</li>
</ul>
<blockquote>
<p>可以通过同构的必要条件不满足说明两个图不同构。</p>
<p>但不能作为充分条件使用。即使满足这三个条件，也不一定是同构。</p>
</blockquote>
<h3 id="通路和回路">9.7 通路和回路</h3>
<h4 id="通路和回路-1">通路和回路</h4>
<p>给定图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中结点和边相继交错出现的序列 <span
class="math display">\[
\Gamma = v_0e_1v_1e_2v_2\dots e_kv_k
\]</span></p>
<ul>
<li>若<span class="math inline">\(\Gamma\)</span>中边<span
class="math inline">\(e_i\)</span>的两端点是<span
class="math inline">\(v_{i-1}\)</span>和<span
class="math inline">\(v_i\)</span>（有向图时<span
class="math inline">\(v_{i-1}\)</span>与<span
class="math inline">\(v_i\)</span>分别是<span
class="math inline">\(e_i\)</span>的始点和终点），<span
class="math inline">\(i = 1, 2, \dots, k\)</span>，则称<span
class="math inline">\(\Gamma\)</span>为结点<span
class="math inline">\(v_0\)</span>到结点<span
class="math inline">\(v_k\)</span>的<strong>通路</strong>。<span
class="math inline">\(v_0\)</span>和<span
class="math inline">\(v_k\)</span>分别称为此通路的始点和终点，统称为通路的<strong>端点</strong>。通路中边的数目<span
class="math inline">\(k\)</span>称为此通路的<strong>长度</strong>。当<span
class="math inline">\(v_0 =
v_k\)</span>时，此通路称为<strong>回路</strong>。</li>
<li>若通路中的所有边互不相同，则称此通路为<strong>简单通路</strong>，否则称为<strong>复杂通路</strong>；若回路中的所有边互不相同，则称此回路为简单回路，否则称为复杂回路。</li>
<li>若通路中的所有结点互不相同，所有边也互不相同，则称此通路为<strong>基本通路</strong>或者<strong>初级通路</strong>；若回路中除<span
class="math inline">\(v_0 =
v_k\)</span>外的所有结点互不相同，所有边也互不相同，则称此回路为基本回路或者初级回路。</li>
</ul>
<p>回路是通路的特殊情况。</p>
<p>在不会引起误解的情况下，一条通路可以用边的序列<span
class="math inline">\(e_1e_2\dots e_n\)</span>来表示；</p>
<p>在简单图中，一条通路也可以用结点的序列<span
class="math inline">\(v_0v_1v_2\dots v_n\)</span>来表示。</p>
<h4 id="通路数量">通路数量</h4>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为线图，<span class="math inline">\(V = \{v_1, v_2,
\dots, v_n\}\)</span>，<span class="math inline">\(A = (a_{ij})_{n
\times n}\)</span>为<span
class="math inline">\(G\)</span>的邻接矩阵，<span
class="math inline">\(A^m = (a_{ij}^{(m)})_{n \times
n}\)</span>。则：</p>
<ul>
<li><span class="math inline">\(a_{ij}^{(m)}\)</span>为从结点<span
class="math inline">\(v_i\)</span>到结点<span
class="math inline">\(v_j\)</span>长度为<span
class="math inline">\(m\)</span>的通路数目；</li>
<li><span class="math inline">\(a_{ii}^{(m)}\)</span>为结点<span
class="math inline">\(v_i\)</span>到自身的长度为<span
class="math inline">\(m\)</span>的回路数目；</li>
<li><span
class="math inline">\(\sum_{i=1}^n\sum_{j=1}^na_{ij}^{(m)}\)</span>是<span
class="math inline">\(G\)</span>中长度为<span
class="math inline">\(m\)</span>的通路（含回路）总数；</li>
<li><span class="math inline">\(\sum_{i=1}^na_{ii}^{(m)}\)</span>是<span
class="math inline">\(G\)</span>中长度为<span
class="math inline">\(m\)</span>的回路总数。</li>
</ul>
<blockquote>
<p><span class="math inline">\(A^m\)</span>就是对矩阵<span
class="math inline">\(A\)</span>求<span
class="math inline">\(m\)</span>次幂。</p>
</blockquote>
<p><strong>推论</strong>  设矩阵<span class="math inline">\(B_m =
(b_{ij})_{n \times n} = A + A^2 + \dots + A^m(m \geq
1)\)</span>，则：</p>
<ul>
<li><span class="math inline">\(b_{ij}\)</span>表示结点<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>长度不大于<span
class="math inline">\(m\)</span>的通路数目；</li>
<li><span
class="math inline">\(\sum_{i=1}^n\sum_{j=1}^nb_{ij}\)</span>表示图中长度不大于<span
class="math inline">\(m\)</span>的通路总数；</li>
<li><span
class="math inline">\(\sum_{i=1}^nb_{ii}\)</span>表示图中所有长度不大于<span
class="math inline">\(m\)</span>的回路总数。</li>
</ul>
<h3 id="可达性和最短通路">9.8 可达性和最短通路</h3>
<h4 id="可达性">可达性</h4>
<p>在图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，<span class="math inline">\(v_i, v_j \in
V\)</span>。如果从<span class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>存在通路，则称<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>是<strong>可达的</strong>，否则称<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>不可达。</p>
<p><strong>规定</strong>  任何结点到自己都是可达的。</p>
<p><strong>定理</strong>  在一个具有<span
class="math inline">\(n\)</span>个结点的图中， 如果从结点<span
class="math inline">\(v_i\)</span>到结点<span
class="math inline">\(v_j\)</span>（<span class="math inline">\(v_i
\not= v_j\)</span>）存在一条通路，则从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>存在一条长度不大于<span
class="math inline">\(n-1\)</span>的<strong>通路</strong>。</p>
<p><strong>推论</strong>  在一个具有<span
class="math inline">\(n\)</span>个结点的图中， 如果从结点<span
class="math inline">\(v_i\)</span>到结点<span
class="math inline">\(v_j\)</span>（<span class="math inline">\(v_i
\not= v_j\)</span>）存在一条通路，则从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>存在一条长度不大于<span
class="math inline">\(n\)</span>的<strong>基本通路</strong>。</p>
<p><strong>定理</strong>  在一个具有<span
class="math inline">\(n\)</span>个结点的图中， 如果存在一条经过结点<span
class="math inline">\(v_i\)</span>的回路，则从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>存在一条长度不大于<span
class="math inline">\(n-1\)</span>的<strong>回路</strong>。</p>
<p><strong>推论</strong>  在一个具有<span
class="math inline">\(n\)</span>个结点的图中， 如果存在一条经过结点<span
class="math inline">\(v_i\)</span>的回路，则从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>存在一条长度不大于<span
class="math inline">\(n\)</span>的<strong>基本回路</strong>。</p>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为线图，<span class="math inline">\(V = \{v_1, v_2,
\dots, v_n\}\)</span>，<span class="math inline">\(A = (a_{ij})_{n
\times n}\)</span>为<span
class="math inline">\(G\)</span>的邻接矩阵，<span
class="math inline">\(A^m = (a_{ij}^{(m)})_{n \times n}\)</span>，<span
class="math inline">\(m = 1, 2, \dots, n\)</span>，<span
class="math inline">\(B_n = (b_{ij}^{(n)})_{n \times n} = A + A^2 +
\dots + A^n\)</span>。则有当<span class="math inline">\(v_i \not=
v_j\)</span>时，如果<span class="math inline">\(b_{ij}^{(n)} &gt;
0\)</span>，那么从<span class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>可达，否则不可达。</p>
<hr />
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是一个线图，其中<span class="math inline">\(V =
\{v_1, v_2, \dots, v_n\}\)</span>，并假定结点已经有了从<span
class="math inline">\(v_1\)</span>到<span
class="math inline">\(v_n\)</span>的次序，称<span
class="math inline">\(n\)</span>阶方阵<span class="math inline">\(P =
(p_{ij})_{n \times n}\)</span>为图<span
class="math inline">\(G\)</span>的<strong>可达性矩阵</strong>，其中<span
class="math inline">\(p_{ij} = \begin{cases}1 &amp; 当v_i到v_j可达 \\ 0
&amp; 否则 \end{cases}, (i, j = 1, 2, 3, \dots, n)\)</span>。</p>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为线图，<span
class="math inline">\(A\)</span>、<span
class="math inline">\(P\)</span>分别是<span
class="math inline">\(G\)</span>的邻接矩阵和可达性矩阵，则有<span
class="math inline">\(P = A \lor A^{(2)} \lor \dots \lor
A^{(n)}\)</span>，这里，<span
class="math inline">\(A^{(i)}\)</span>表示做矩阵布尔乘法的<span
class="math inline">\(i\)</span>次幂。</p>
<h4 id="最短通路">最短通路</h4>
<p>如果<span class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>可达，则称长度最短的通路为从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>的<strong>短程线</strong>，从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>的短程线的长度称为从<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>的<strong>距离</strong>，记为<span
class="math inline">\(d(v_i, v_j)\)</span>。如果<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>不可达，则通常记为<span
class="math inline">\(d(v_i, v_j) = \infty\)</span>。</p>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>为线图，<span class="math inline">\(V = \{v_1, v_2,
\dots, v_n\}\)</span>，<span class="math inline">\(A = (a_{ij})_{n
\times n}\)</span>为<span
class="math inline">\(G\)</span>的邻接矩阵，<span
class="math inline">\(A^m = (a_{ij}^{(m)})_{n \times n}\)</span>，<span
class="math inline">\(m = 1, 2, \dots, n\)</span>，则 <span
class="math display">\[
d(v_i, v_j) = \begin{cases}
\infty &amp; 如果所有a_{ij}^{(m)}均为0 \\
k &amp; k = \min\{m | a_{ij}^{(m)} \not= 0 \}
\end{cases}, (m = 1, 2, 3, \dots, n)
\]</span></p>
<h3 id="无向图的连通性">9.9 无向图的连通性</h3>
<h4 id="无向图的连通性-1">无向图的连通性</h4>
<p>若无向图<span
class="math inline">\(G\)</span>中的两个结点都是可达的，则称<span
class="math inline">\(G\)</span>是<strong>连通图</strong>，否则称<span
class="math inline">\(G\)</span>是<strong>非连通图</strong>或<strong>分离图</strong>。</p>
<ul>
<li>无向完全图<span class="math inline">\(K_n\)</span>（<span
class="math inline">\(n \geq 1\)</span>）都是连通图；</li>
<li>多于一个结点的零图都是非连通图；</li>
<li>非平凡无向线图<span
class="math inline">\(G\)</span>是连通图，当且仅当它的可达性矩阵<span
class="math inline">\(P\)</span>的所有元素均为1。</li>
</ul>
<p><strong>定理</strong>  无向图<span class="math inline">\(G =
\left&lt;V, E\right&gt;\)</span>中结点之间的可达关系<span
class="math inline">\(R = \{\left&lt;u, v\right&gt; | u, v \in V,
u到v可达 \}\)</span>，则<span class="math inline">\(R\)</span>是<span
class="math inline">\(V\)</span>上的<strong>等价关系</strong>。</p>
<p>无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中结点之间的可达关系<span
class="math inline">\(R\)</span>的每个等价类导出的子图都称为<span
class="math inline">\(G\)</span>的一个<strong>连通分支</strong>。用<span
class="math inline">\(p(G)\)</span>表示<span
class="math inline">\(G\)</span>中的连通分支个数。</p>
<h4 id="点割集与边割集">点割集与边割集</h4>
<p><strong>图的删除操作</strong></p>
<p>对于一个无向图<span class="math inline">\(G\)</span>，</p>
<ul>
<li><span class="math inline">\(G - e\)</span>表示从图<span
class="math inline">\(G\)</span>中删除边<span
class="math inline">\(e\)</span>，<span class="math inline">\(G -
E&#39;\)</span>表示从图<span
class="math inline">\(G\)</span>中删除边的集合<span
class="math inline">\(E&#39;\)</span>中所有边；</li>
<li><span class="math inline">\(G - v\)</span>表示从图<span
class="math inline">\(G\)</span>中删除结点<span
class="math inline">\(v\)</span>及其关联的所有边，<span
class="math inline">\(G - V&#39;\)</span>表示从图<span
class="math inline">\(G\)</span>中删除结点集合<span
class="math inline">\(V&#39;\)</span>中所有结点以及这些结点关联的所有的边。</li>
</ul>
<p><strong>点割集</strong></p>
<p>设无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，若存在结点子集<span class="math inline">\(V&#39;
\subset V\)</span>，使得<span class="math inline">\(p(G - V&#39;) &gt;
p(G)\)</span>，而对于任意的<span class="math inline">\(V&#39;&#39;
\subset V&#39;\)</span>，均有<span class="math inline">\(p(G -
V&#39;&#39;) = p(G)\)</span>，则称<span
class="math inline">\(V&#39;\)</span>为<span
class="math inline">\(G\)</span>的一个<strong>点割集</strong>。特别地，若点割集中只有一个结点<span
class="math inline">\(v\)</span>，则称<span
class="math inline">\(v\)</span>为<strong>割点</strong>。</p>
<p><strong>边割集</strong></p>
<p>设无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，若存在边的子集<span class="math inline">\(E&#39;
\subset E\)</span>，使得<span class="math inline">\(p(G - E&#39;) &gt;
p(G)\)</span>，而对于任意的<span class="math inline">\(E&#39;&#39;
\subset E&#39;\)</span>，均有<span class="math inline">\(p(G -
E&#39;&#39;) = p(G)\)</span>，则称<span
class="math inline">\(E&#39;\)</span>为<span
class="math inline">\(G\)</span>的一个<strong>边割集</strong>。特别地，若边割集中只有一条边<span
class="math inline">\(e\)</span>，则称<span
class="math inline">\(e\)</span>为<strong>割边</strong>。</p>
<h4 id="连通度">连通度</h4>
<p>设无向连通图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，</p>
<ul>
<li>称<span class="math inline">\(\kappa(G) = \min\{|V&#39;|\
|V&#39;为G的点割集或G - V&#39;为平凡图 \}\)</span>为<span
class="math inline">\(G\)</span>的点连通度，若<span
class="math inline">\(\kappa(G) \geq k\)</span>，则称<span
class="math inline">\(G\)</span>为<span
class="math inline">\(k\)</span>-连通图。</li>
<li>称<span class="math inline">\(\lambda(G) = \min\{|E&#39;|\
|E&#39;为G的边割集 \}\)</span>为<span
class="math inline">\(G\)</span>的边连通度，若<span
class="math inline">\(\lambda(G) \geq k\)</span>，则称<span
class="math inline">\(G\)</span>为<span
class="math inline">\(k\)</span>边-连通图。</li>
</ul>
<p>若<span class="math inline">\(G\)</span>是平凡图，则<span
class="math inline">\(V&#39; = \varnothing\)</span>，<span
class="math inline">\(E&#39; = \varnothing\)</span>，所以<span
class="math inline">\(\kappa(G) = \lambda(G) = 0\)</span>；</p>
<p>若<span class="math inline">\(G\)</span>是完全图<span
class="math inline">\(K_n\)</span>，则<span
class="math inline">\(G\)</span>无点割集。当删除<span
class="math inline">\(n - 1\)</span>个结点后成为平凡图，因而<span
class="math inline">\(\kappa(G) = n - 1\)</span>。显然，<span
class="math inline">\(\lambda(G) = n - 1\)</span>；</p>
<p>若<span class="math inline">\(G\)</span>中存在割点，则<span
class="math inline">\(\kappa(G) = 1\)</span>。若<span
class="math inline">\(G\)</span>中存在割边，则<span
class="math inline">\(\lambda(G) = 1\)</span>。</p>
<p>若<span
class="math inline">\(G\)</span>是非连通图，因为不用删除结点或边就已经不连通了，所以规定非连通图的点连通度和边连通度均为0。</p>
<h3 id="有向图的连通性">9.10 有向图的连通性</h3>
<h4 id="有向图的连通性-1">有向图的连通性</h4>
<blockquote>
<p>由于有向图中边都有方向性，因此有向图结点之间的可达关系仅仅具有自反性和传递性，而不具有对称性。因此，有向图中的可达关系不是等价关系。</p>
</blockquote>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是一个有向图，</p>
<ul>
<li>略去<span
class="math inline">\(G\)</span>中所有有向边的方向得到的无向图是连通图，则称有向图<span
class="math inline">\(G\)</span>是<strong>连通图</strong>或称为<strong>弱连通图</strong>。否则称<span
class="math inline">\(G\)</span>是<strong>非连通图</strong>；</li>
<li>若<span
class="math inline">\(G\)</span>中任何一对结点之间至少有一个结点到另一个结点是可达的，则称<span
class="math inline">\(G\)</span>是<strong>单向连通图</strong>；</li>
<li>若<span
class="math inline">\(G\)</span>中任何一对结点之间都是相互可达的，则称<span
class="math inline">\(G\)</span>是<strong>强连通图</strong>。</li>
</ul>
<p>显然，强连通图必是单向连通图；单向连通图必是连通图。但反之均不成立。</p>
<figure>
<img src="https://s1.ax1x.com/2020/05/22/YLtFQe.png" alt="YLtFQe.png" />
<figcaption aria-hidden="true">YLtFQe.png</figcaption>
</figure>
<p><strong>判定</strong></p>
<p>有向图<span
class="math inline">\(G\)</span>是<strong>强连通图</strong>的充分必要条件是<span
class="math inline">\(G\)</span>中存在一条经过所有结点至少一次的回路。</p>
<p>有向图<span
class="math inline">\(G\)</span>是<strong>单向连通图</strong>的充分必要条件是<span
class="math inline">\(G\)</span>中存在一条经过所有结点至少一次的通路。</p>
<p><strong>邻接矩阵判定</strong></p>
<p>由邻接矩阵<span class="math inline">\(A\)</span>，求出可达性矩阵<span
class="math inline">\(P\)</span>，</p>
<ul>
<li>有向线图<span
class="math inline">\(G\)</span>是<strong>强连通图</strong>，当且仅当它的可达性矩阵<span
class="math inline">\(P\)</span>的所有元素均为1；</li>
<li>有向线图<span
class="math inline">\(G\)</span>是<strong>单向连通图</strong>，当且仅当它的可达性矩阵<span
class="math inline">\(P\)</span>及其转置矩阵<span
class="math inline">\(P^T\)</span>经过布尔加运算后所得的矩阵<span
class="math inline">\(P&#39; = P \lor
P^T\)</span>中除主对角元外其余元素均为1；</li>
<li>有向线图<span
class="math inline">\(G\)</span>是<strong>弱连通图</strong>，当且仅当它的邻接矩阵<span
class="math inline">\(A\)</span>及其转置矩阵<span
class="math inline">\(A^T\)</span>经布尔加运算所得的矩阵<span
class="math inline">\(A&#39; = A \lor
A^T\)</span>作为邻接矩阵而求得的可达性矩阵<span
class="math inline">\(P&#39;\)</span>中所有元素均为1.</li>
</ul>
<h4 id="连通分支">连通分支</h4>
<p>在有向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，设<span
class="math inline">\(G&#39;\)</span>是<span
class="math inline">\(G\)</span>的子图，如果</p>
<ul>
<li><span
class="math inline">\(G&#39;\)</span>是强连通的（单向连通的、弱连通的）；</li>
<li>对任意<span class="math inline">\(G&#39;&#39; \subseteq
G\)</span>，若<span class="math inline">\(G&#39; \subset
G&#39;&#39;\)</span>，则<span
class="math inline">\(G&#39;&#39;\)</span>不是强连通的（单向连通的、弱连通的）；</li>
</ul>
<p>那么称<span class="math inline">\(G&#39;\)</span>为<span
class="math inline">\(G\)</span>的<strong>强连通分支</strong>（<strong>单向连通分支</strong>、<strong>弱连通分支</strong>），或称为<strong>强分图</strong>（<strong>单向分图</strong>、<strong>弱分图</strong>）。</p>
<blockquote>
<p>弱连通分支也就是忽略边的方向所对应的无向图的连通分支；</p>
<p>注意把握强（单向、弱）连通分支的<strong>极大性</strong>特点，即，任意增加一个结点或一条边就不是强（单向、弱）连通的了。</p>
</blockquote>
<p><strong>判定</strong></p>
<p>在有向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，它的每一个结点位于且仅位于一个强（弱）连通分支中，至少位于一个单向连通分支中。</p>
<p>在有向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>中，它的每一条边至多在一个强连通分支中；至少在一个单向连通分支中；在且仅在一个弱连通分支中。</p>
<blockquote>
<ul>
<li>弱连通分支：图的不互连部分</li>
<li>强连通分支：出度为0或入度为0的结点，极大回路，……</li>
<li>单向连通分支：极大通路</li>
</ul>
</blockquote>
<h3 id="最短通路问题">9.11 最短通路问题</h3>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是一个简单无向赋权图，</p>
<ul>
<li>该图中一条通路上所有边的权值之和，称为这条通路的<strong>长度</strong>；</li>
<li>两个结点间长度最短的通路，称为这两个结点间的<strong>最短通路</strong>。</li>
</ul>
<h4
id="单源点的最短通路dijkstra算法">单源点的最短通路——Dijkstra算法</h4>
<p><strong>基本思想</strong></p>
<ul>
<li>将结点集合<span
class="math inline">\(V\)</span>分为两部分：一部分称为具有<span
class="math inline">\(P\)</span>（永久性）标号的集合，另一部分称为具有<span
class="math inline">\(T\)</span>（暂时性）标号的集合；</li>
<li>所谓结点<span class="math inline">\(v\)</span>的<span
class="math inline">\(P\)</span>标号是指从<span
class="math inline">\(v_1\)</span>到<span
class="math inline">\(v\)</span>的最短通路的长度；而结点<span
class="math inline">\(u\)</span>的<span
class="math inline">\(T\)</span>标号是指从<span
class="math inline">\(v_1\)</span>到<span
class="math inline">\(u\)</span>的某条通路的长度；</li>
<li>首先将<span class="math inline">\(v_1\)</span>取为<span
class="math inline">\(P\)</span>标号，其余结点为<span
class="math inline">\(T\)</span>标号，然后逐步将具有<span
class="math inline">\(T\)</span>标号的结点改为<span
class="math inline">\(P\)</span>标号。</li>
</ul>
<ol type="1">
<li><p>初始化：将源结点<span class="math inline">\(v_1\)</span>置为<span
class="math inline">\(P\)</span>标号，<span class="math inline">\(d(v_1)
= 0, P = \{v_1\}, v_i \in V\)</span>，将所有<span
class="math inline">\(v_i \not= v_1\)</span>置为<span
class="math inline">\(T\)</span>标号，即<span class="math inline">\(T =
V - P\)</span>，且 <span class="math display">\[
d(v_i) = \begin{cases}
w(v_1, v_i) &amp; \text{if }(v_1, v_i) \in E \\
\infty &amp; \text{if }(v_1, v_i) \not\in E
\end{cases}
\]</span></p></li>
<li><p>找最小：寻找具有最小值的<span
class="math inline">\(T\)</span>标号的结点。若为<span
class="math inline">\(v_k\)</span>，则将<span
class="math inline">\(v_k\)</span>的<span
class="math inline">\(T\)</span>标号改为<span
class="math inline">\(P\)</span>标号，且<span class="math inline">\(P =
P \cup \{v_k\}, T = T - \{v_k\}\)</span>。</p></li>
<li><p>修改：修改与<span
class="math inline">\(v_k\)</span>相邻的结点的<span
class="math inline">\(T\)</span>标号值。<span class="math inline">\(v_i
\in V\)</span> <span class="math display">\[
d(v_i) = \begin{cases}
d(v_k) + w(v_k, v_i) &amp; \text{if }d(v_k) + w(v_k, v_i) &lt; d(v_i) \\
d(v_i) &amp; \text{else}
\end{cases}
\]</span></p></li>
<li><p>重复2-3，直到所有结点都改为<span
class="math inline">\(P\)</span>标号。</p></li>
</ol>
<h4
id="任意两点间的最短通路floyd算法">任意两点间的最短通路——Floyd算法</h4>
<p><strong>基本思想</strong></p>
<ul>
<li>设<span
class="math inline">\(n\)</span>为图中的结点个数，从矩阵<span
class="math inline">\(D^{(0)} = (w_{ij})_{n \times
n}\)</span>（即图的长度矩阵）开始，依次构造出<span
class="math inline">\(n\)</span>个矩阵<span
class="math inline">\(D^{(1)}, D^{(2)}, \dots,
D^{(n)}\)</span>，其中<span
class="math inline">\(D^{(k)}\)</span>表示从结点<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>而中间结点仅属于集合<span
class="math inline">\(\{v_1, v_2, \dots,
v_k\}\)</span>的所有通路中的最短通路长度；</li>
<li>若已知<span class="math inline">\(D^{(k-1)} =
(d_{ij}^{(k-1)})\)</span>，则<span class="math inline">\(D^{(k)} =
(d_{ij}^{(k)})\)</span>的元素为：<span
class="math inline">\(d_{ij}^{(k)} = \min\{d_{ij}^{(k-1)},
d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\}\)</span>；</li>
<li><span class="math inline">\(D^{(n)} =
(d_{ij}^{(n)})\)</span>的元素<span
class="math inline">\(d_{ij}^{(n)}\)</span>就是从结点<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>的最短通路长度。</li>
</ul>
<h4 id="两种算法的比较">两种算法的比较</h4>
<ul>
<li>Dijkstra算法求指定结点到其它结点间的最短通路，Floyd算法求出任意两点间的最短通路；</li>
<li>在求解多源最短路径问题上，二者的时间复杂度相当，都是<span
class="math inline">\(O(n^3)\)</span>；</li>
<li>二者均能处理无向赋权图和有向赋权图；</li>
<li>Dijkstra算法不能求解有负权边的图，而Floyd算法可以求解带负权边的图。</li>
</ul>
<h2 id="第十章-树">第十章 树</h2>
<h3 id="认识树">10.1 认识树</h3>
<h4 id="树的模型">树的模型</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">1 --&gt; 2 --&gt; 4 --&gt; 7</span><br><span class="line">1 --&gt; 3 --&gt; 5</span><br><span class="line">3 --&gt; 6 --&gt; 9</span><br><span class="line">4 --&gt; 8</span><br></pre></td></tr></table></figure>
<h4 id="树的应用">树的应用</h4>
<ul>
<li>二元搜索树</li>
<li>决策树</li>
<li>前缀码（配合哈夫曼算法）</li>
</ul>
<h3 id="无向树">10.2 无向树</h3>
<h4 id="定义-4">定义</h4>
<p>连通而不含回路的无向图称为<strong>无向树</strong>，简称<strong>树</strong>，常用<span
class="math inline">\(T\)</span>表示树。</p>
<p>树中度数为1的结点称为<strong>叶</strong>；度数大于1的结点称为<strong>分支点</strong>或<strong>内部结点</strong>。</p>
<p>每个连通分支都是树的无向图称为<strong>森林</strong>。</p>
<p>平凡图称为<strong>平凡树</strong>。</p>
<blockquote>
<p>容易看出，树中没有环和平行边，因此一定是简单图，并且在任何非平凡树中，都无度数为0的结点。</p>
<p>一棵树也可以叫做森林。</p>
</blockquote>
<h4 id="树的性质等价定义">树的性质（等价定义）</h4>
<p><strong>定理</strong>  设无向图<span class="math inline">\(G =
\left&lt;V, E\right&gt;\)</span>，<span class="math inline">\(|V| =
n\)</span>，<span class="math inline">\(|E| =
m\)</span>，下列各命题是等价的：</p>
<ul>
<li><span class="math inline">\(G\)</span>连通而不含回路（即<span
class="math inline">\(G\)</span>是树）；</li>
<li><span class="math inline">\(G\)</span>中无回路，且<span
class="math inline">\(m = n - 1\)</span>；</li>
<li><span class="math inline">\(G\)</span>是连通的，且<span
class="math inline">\(m = n - 1\)</span>；</li>
<li><span
class="math inline">\(G\)</span>中无回路，但在任二结点之间增加一条新边，就得到唯一的一条基本回路；</li>
<li><span
class="math inline">\(G\)</span>是连通的，但删除任一条边后，便不连通；<span
class="math inline">\((n \geq 2)\)</span></li>
<li><span
class="math inline">\(G\)</span>中每一对结点之间有唯一一条基本通路。<span
class="math inline">\((n \geq 2)\)</span></li>
</ul>
<p><strong>特点</strong></p>
<p>在结点给定的无向图中，</p>
<ul>
<li>树是边数最多的无回路图；</li>
<li>树是边数最少的连通图。</li>
</ul>
<p>由此可知，在无向图<span class="math inline">\(G = (n,
m)\)</span>中，</p>
<ul>
<li>若<span class="math inline">\(m &lt; n - 1\)</span>，则<span
class="math inline">\(G\)</span>是不连通的；</li>
<li>若<span class="math inline">\(m &gt; n - 1\)</span>，则<span
class="math inline">\(G\)</span>必含回路。</li>
</ul>
<h4 id="性质应用">性质应用</h4>
<p><strong>定理</strong>  任意非平凡树<span class="math inline">\(T =
(n, m)\)</span>都至少有两片叶。</p>
<h3 id="生成树">10.3 生成树</h3>
<h4 id="定义-5">定义</h4>
<p>给定图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，</p>
<ul>
<li>若<span
class="math inline">\(G\)</span>的某个生成子图是树，则称之为<span
class="math inline">\(G\)</span>的<strong>生成树</strong>，记为<span
class="math inline">\(T_G\)</span>。生成树<span
class="math inline">\(T_G\)</span>中的边称为<strong>树枝</strong>。</li>
<li><span class="math inline">\(G\)</span>中不在<span
class="math inline">\(T_G\)</span>中的边称为<strong>弦</strong>，<span
class="math inline">\(T_G\)</span>的所有弦的集合称为生成树的<strong>补</strong>。</li>
</ul>
<p><strong>生成树存在的条件</strong></p>
<p><strong>定理</strong>  一个图<span class="math inline">\(G =
\left&lt;V, E\right&gt;\)</span>存在生成树<span
class="math inline">\(T_G = \left&lt;V_T,
E_T\right&gt;\)</span>的充分必要条件是<span
class="math inline">\(G\)</span>是连通的。</p>
<h4 id="算法">算法</h4>
<p>求连通图<span class="math inline">\(G = (n,
m)\)</span>的生成树的算法：</p>
<ul>
<li><p><strong>破圈法</strong></p>
<p>循环找到图中的回路并删除回路中的一条边，直到删除的边的总数为<span
class="math inline">\(m - n + 1\)</span>.</p></li>
<li><p><strong>避圈法</strong></p>
<p>循环选取<span
class="math inline">\(G\)</span>中一条与已选取的边不构成回路的边，直到选取的边的总数为<span
class="math inline">\(n - 1\)</span>.</p></li>
</ul>
<p><strong>生成树的广度优先搜索算法</strong></p>
<p>连通图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>，</p>
<ol type="1">
<li>任选<span class="math inline">\(s \in V\)</span>，将<span
class="math inline">\(s\)</span>标记为0，令<span class="math inline">\(L
= \{s\}, V = V - \{s\}, k = 0, E_G = \varnothing\)</span>；</li>
<li>如果<span class="math inline">\(V =
\varnothing\)</span>，则结束，<span
class="math inline">\(E_G\)</span>为所求的生成树中包含的所有边。否则令<span
class="math inline">\(k = k+1\)</span>；</li>
<li>依次对<span class="math inline">\(L\)</span>中所有标记为<span
class="math inline">\(k-1\)</span>的结点<span
class="math inline">\(v\)</span>，如果它与<span
class="math inline">\(V\)</span>中的结点<span
class="math inline">\(w\)</span>相邻接，则将<span
class="math inline">\(w\)</span>标记为<span
class="math inline">\(k\)</span>，指定<span
class="math inline">\(v\)</span>为<span
class="math inline">\(w\)</span>的前驱，令<span class="math inline">\(L
= L \cup \{w\}, V = V - \{w\}, E_G = E_G \cup \{(v,
w)\}\)</span>，转步骤⒉。</li>
</ol>
<h3 id="最小生成树">10.4 最小生成树</h3>
<h4 id="定义-6">定义</h4>
<p>设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是连通的赋权图，<span
class="math inline">\(T\)</span>是<span class="math inline">\(G\)</span>
一棵生成树，<span
class="math inline">\(T\)</span>的每个树枝所赋权值之和称为<span
class="math inline">\(T\)</span>的<strong>权</strong>，记为<span
class="math inline">\(w(T)\)</span>。<span
class="math inline">\(G\)</span> 具有最小权的生成树称为<span
class="math inline">\(G\)</span>的<strong>最小生成树</strong>。</p>
<blockquote>
<p>一个无向图的生成树不是唯一的，同样地，一个赋权图的最小生成树也不一定是唯一的。</p>
</blockquote>
<h4 id="kruskal算法">Kruskal算法</h4>
<p>其要点是，在与已选取的边不构成回路的边中选取最小者。</p>
<ol type="1">
<li>在<span class="math inline">\(G\)</span>中选取最小权边<span
class="math inline">\(e_1\)</span>，置<span class="math inline">\(i =
1\)</span>，<span class="math inline">\(E_T = \{e_1\}\)</span>；</li>
<li>当<span class="math inline">\(i = n -
1\)</span>时，结束，否则转步骤⒊；</li>
<li>在<span class="math inline">\(G\)</span>中选取不在<span
class="math inline">\(E_T\)</span>中的边<span
class="math inline">\(e_{i+1}\)</span>，使<span
class="math inline">\(E_T \cup \{e_{i+1}\}\)</span>中无回路且<span
class="math inline">\(e_{i+1}\)</span>是满足此条件的最小权边；</li>
<li>置<span class="math inline">\(i + i + 1\)</span>，<span
class="math inline">\(E_T = E_T \cup
\{e_{i+1}\}\)</span>，转步骤⒉。</li>
</ol>
<h4 id="prim算法">Prim算法</h4>
<p>其要点是，从任意结点开始，每次增加一条最小权边构成一棵新树。</p>
<ol type="1">
<li>在<span class="math inline">\(G\)</span>中任意选取一个结点<span
class="math inline">\(v_1\)</span>，置<span class="math inline">\(V_T =
\{v_1\}, E_T = \varnothing, k = 1\)</span>；</li>
<li>在<span class="math inline">\(V - V_T\)</span>中选取与某个<span
class="math inline">\(v_i \in V_T\)</span>邻接的结点<span
class="math inline">\(v_j\)</span>，使得边<span
class="math inline">\((v_i, v_j)\)</span>的权最小，置<span
class="math inline">\(V_T = V_T \cup \{v_j\}, E_T = E_T \cup \{(v_i,
v_j)\}, k = k + 1\)</span>；</li>
<li>重复步骤⒉，直到<span class="math inline">\(k = |V|\)</span>。</li>
</ol>
<h3 id="根树">10.5 根树</h3>
<h4 id="定义-7">定义</h4>
<p>一个有向图，若略去所有有向边的方向所得到的无向图是一棵树，则这个有向图称为<strong>有向树</strong>。</p>
<p>一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为<strong>根树</strong>或<strong>外向树</strong>，出度为0的结点称为<strong>叶</strong>；入度为1，出度大于0
的结点称为<strong>内点</strong>；又将内点和根统称为<strong>分支点</strong>。</p>
<p>在根树中，从根到任一结点<span
class="math inline">\(v\)</span>的通路长度，称为该结点的<strong>层数</strong>；称层数相同的结点在同一层上；所有结点的层数中最大的称为根树的<strong>高</strong>。</p>
<blockquote>
<p>习惯上使用倒置法来画根树，即把根画在最上方，叶画在下方，有向边的方向均指向下方，这样就可以省去全部的箭头，不会发生误解。</p>
</blockquote>
<h4 id="家族关系">家族关系</h4>
<p>在根树中，若从结点<span class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>可达，则称<span
class="math inline">\(v_i\)</span>是<span
class="math inline">\(v_j\)</span>的<strong>祖先</strong>，<span
class="math inline">\(v_j\)</span>是<span
class="math inline">\(v_i\)</span>的<strong>后代</strong>；又若<span
class="math inline">\(\left&lt;v_i,
v_j\right&gt;\)</span>是根树中的有向边，则称<span
class="math inline">\(v_i\)</span>是<span
class="math inline">\(v_j\)</span>的<strong>父亲</strong>，<span
class="math inline">\(v_j\)</span>是<span
class="math inline">\(v_j\)</span>的<strong>儿子</strong>；如果两个结点是同一个结点的儿子，则称这两个结点是<strong>兄弟</strong>。</p>
<h4 id="k元树"><span class="math inline">\(k\)</span>元树</h4>
<p>如果在根树中规定了每一层上结点的次序，这样的根树称为<strong>有序树</strong>。</p>
<p>在根树<span class="math inline">\(T\)</span>中，</p>
<ul>
<li>若每个分支点至多有<span
class="math inline">\(k\)</span>个儿子，则称<span
class="math inline">\(T\)</span>为<strong><span
class="math inline">\(k\)</span>元树</strong>；</li>
<li>若每个分支点都恰有<span
class="math inline">\(k\)</span>个儿子，则称<span
class="math inline">\(T\)</span>为满<span
class="math inline">\(k\)</span>元树；</li>
<li>若<span class="math inline">\(k\)</span>元树<span
class="math inline">\(T\)</span>是有序的，则称<span
class="math inline">\(T\)</span>为<strong><span
class="math inline">\(k\)</span>元有序树</strong>；</li>
<li>若满<span class="math inline">\(k\)</span>元树<span
class="math inline">\(T\)</span>是有序的，则称<span
class="math inline">\(T\)</span>为<strong>满<span
class="math inline">\(k\)</span>元有序树</strong>；</li>
<li>任一结点<span
class="math inline">\(v\)</span>及其所有后代导出的子图<span
class="math inline">\(T&#39;\)</span>称为<span
class="math inline">\(T\)</span>的<strong>以<span
class="math inline">\(v\)</span>为根的子树</strong>。</li>
</ul>
<p><strong>二元有序树</strong></p>
<p>二元有序树的每个结点<span
class="math inline">\(v\)</span>至多有两个儿子，分别称为<span
class="math inline">\(v\)</span>的<strong>左儿子</strong>和<strong>右儿子</strong>。二元有序树的每个结点<span
class="math inline">\(v\)</span>至多有两棵子树，分别称为<span
class="math inline">\(v\)</span>的<strong>左子树</strong>和<strong>右子树</strong>。</p>
<p><strong>满<span
class="math inline">\(k\)</span>元树的性质</strong></p>
<p><strong>定理</strong>  在满<span
class="math inline">\(k\)</span>元树中，若叶数为<span
class="math inline">\(t\)</span>，分支点数为<span
class="math inline">\(i\)</span>，则有 <span class="math display">\[
(k-1) \times i = t - 1
\]</span></p>
<h3 id="根树的遍历">10.6 根树的遍历</h3>
<h4 id="二元树的遍历">二元树的遍历</h4>
<p><strong>二元树的先根次序遍历算法</strong></p>
<ol type="1">
<li>访问根；</li>
<li>按先根次序遍历根的左子树；</li>
<li>按先根次序遍历根的右子树。</li>
</ol>
<p><strong>二元树的中根次序遍历算法</strong></p>
<ol type="1">
<li>按先根次序遍历根的左子树；</li>
<li>访问根；</li>
<li>按先根次序遍历根的右子树。</li>
</ol>
<p><strong>二元树的后根次序遍历算法</strong></p>
<ol type="1">
<li>按先根次序遍历根的左子树；</li>
<li>按先根次序遍历根的右子树；</li>
<li>访问根。</li>
</ol>
<h4 id="表达式的记法">表达式的记法</h4>
<p>可以用二叉树表示一些复杂的表达式，如复合命题，集合的组合，以及算术表达式。</p>
<p><strong>例</strong>：有如下二叉树表示表达式<span
class="math inline">\((x+y)^2+(x-4)\div3\)</span></p>
<figure>
<img src="https://s1.ax1x.com/2020/05/29/tmUWAU.png" alt="tmUWAU.png" />
<figcaption aria-hidden="true">tmUWAU.png</figcaption>
</figure>
<p><strong>中缀形式</strong>：<span
class="math inline">\((x+y)\uparrow2+(x-4)/3\)</span></p>
<p>对表达式的二叉树进行中根遍历时，就得到了它的中缀形式。需要加括号规定运算顺序以防止二义性。</p>
<p><strong>前缀形式</strong>：<span
class="math inline">\(+\uparrow+xy2/-x43\)</span></p>
<p>对表达式的二叉树进行先根遍历时，就得到了它的前缀形式。前缀形式的最大优点是无二义性，所以不再需要括号。</p>
<p>写成前缀形式的表达式称为波兰符号法。表达式的求值方式是从右向左。</p>
<p><strong>后缀形式</strong>：<span class="math inline">\(xy+2\uparrow
x4-3/+\)</span></p>
<p>对表达式的二叉树进行后根遍历时，就得到了它的后缀形式。后缀形式同样无二义性，所以也不再需要括号。</p>
<p>写成后缀形式的表达式称为逆波兰符号法。表达式的求值方式是从左向右。</p>
<h4 id="根树的遍历-1">根树的遍历</h4>
<p><strong>根树的先根次序遍历算法</strong></p>
<ol type="1">
<li>访问根；</li>
<li>按先根次序从左向右遍历根的各子树。</li>
</ol>
<p><strong>根树的后根次序遍历算法</strong></p>
<ol type="1">
<li>按先根次序从左向右遍历根的各子树；</li>
<li>访问根。</li>
</ol>
<h3 id="最优树与哈夫曼算法扩展内容">10.7
最优树与哈夫曼算法〔扩展内容〕</h3>
<h4 id="前缀码">前缀码</h4>
<p>设<span class="math inline">\(a_1a_2\dots
a_{n-1}a_n\)</span>为长度为<span
class="math inline">\(n\)</span>的符号串，称其子串<span
class="math inline">\(a_1, a_1a_2, \dots, a_1a_2 \dots
a_{n-1}\)</span>分别为<span class="math inline">\(a_1a_2\dots
a_{n-1}a_n\)</span>的长度为<span class="math inline">\(1, 2, \dots,
n-1\)</span>的<strong>前缀</strong>。</p>
<p>设<span class="math inline">\(A = \{b_1, b_2, \dots, b_m
\}\)</span>是一个符号串集合，若对任意<span class="math inline">\(b_i,
b_j \in A, b_i \not= b_j\)</span>，<span
class="math inline">\(b_i\)</span>不是<span
class="math inline">\(b_j\)</span>的前缀，<span
class="math inline">\(b_j\)</span>也不是<span
class="math inline">\(b_i\)</span>的前缀，则称<span
class="math inline">\(A\)</span>为<strong>前缀码</strong>。若符号串<span
class="math inline">\(b_i(i = 1, 2, \dots,
m)\)</span>中，只出现0和1两个符号，则称<span
class="math inline">\(A\)</span>为<strong>二元前缀码</strong>。</p>
<p><strong>用二元树产生二元前缀码</strong></p>
<p>给定一棵二元树<span class="math inline">\(T\)</span>，假设它有<span
class="math inline">\(t\)</span>片树叶。设<span
class="math inline">\(v\)</span>是<span
class="math inline">\(T\)</span>任意一个分支点，则<span
class="math inline">\(v\)</span>至少有一个儿子，至多有两个儿子。若<span
class="math inline">\(v\)</span>有两个儿子，则在由<span
class="math inline">\(v\)</span>引出的两条边上，左边的标上0，右边的标上1；若<span
class="math inline">\(v\)</span>只有一个儿子，在<span
class="math inline">\(v\)</span>引出的边上可标0也可标1。设<span
class="math inline">\(w\)</span>为<span
class="math inline">\(T\)</span>的任意一片树叶，从树根到<span
class="math inline">\(w\)</span>的通路上各边的标号组成的符号串放在<span
class="math inline">\(w\)</span>处，<span
class="math inline">\(t\)</span>片树叶处的<span
class="math inline">\(t\)</span>个符号串组成的集合为一个二元前缀码。</p>
<h4 id="最优树">最优树</h4>
<p>设有一棵二元树<span
class="math inline">\(T\)</span>，若对其所有的<span
class="math inline">\(t\)</span>片叶赋以权值<span
class="math inline">\(w_1, w_2, \dots,
w_t\)</span>，则称之为<strong>赋权二元树</strong>；若权为<span
class="math inline">\(w_i\)</span>的叶的层数为<span
class="math inline">\(L(w_i)\)</span>，则称<span
class="math inline">\(W(T) = \sum_{i=1}^t w_i\times
L(w_i)\)</span>为该赋权二元树的<strong>权</strong>；而在所有赋权<span
class="math inline">\(w_1, w_2, \dots, w_t\)</span>的二元树中，<span
class="math inline">\(W(T)\)</span>最小的二元树称为<strong>最优树</strong>。</p>
<h4 id="哈夫曼算法">哈夫曼算法</h4>
<ol type="1">
<li>初始：令<span class="math inline">\(S = \{w_1, w_2, \dots, w_t
\}\)</span>；</li>
<li>从<span class="math inline">\(S\)</span>中取出两个最小的权<span
class="math inline">\(w_i\)</span>和<span
class="math inline">\(w_j\)</span>，画结点<span
class="math inline">\(v_i\)</span>和<span
class="math inline">\(v_j\)</span>，分别带权<span
class="math inline">\(w_i\)</span>和<span
class="math inline">\(w_j\)</span>。画<span
class="math inline">\(v_i\)</span>和<span
class="math inline">\(v_j\)</span>的父亲<span
class="math inline">\(v\)</span>，令<span
class="math inline">\(v\)</span>带权<span class="math inline">\(w_i +
w_j\)</span>；</li>
<li>令<span class="math inline">\(S = (S - \{w_i, w_j\}) \cup \{w_i +
w_j\}\)</span>；</li>
<li>判断<span
class="math inline">\(S\)</span>是否只含一个元素？若是，则停止，否则转⒉。</li>
</ol>
<h2 id="第十一章-特殊图">第十一章 特殊图</h2>
<h3 id="欧拉图">11.1 欧拉图</h3>
<blockquote>
<p><strong>哥尼斯堡七桥问题</strong></p>
<figure>
<img src="https://s1.ax1x.com/2020/05/29/tmrQbR.png" alt="tmrQbR.png" />
<figcaption aria-hidden="true">tmrQbR.png</figcaption>
</figure>
</blockquote>
<h4 id="定义-8">定义</h4>
<p>设<span
class="math inline">\(G\)</span>是无孤立结点的图，若存在一条通路（回路），经过图中每边一次且仅一次，则称此通路（回路）为该图的一条<strong>欧拉通路</strong>（回路）。具有欧拉回路的图称为<strong>欧拉图</strong>。</p>
<p><strong>规定</strong>  平凡图为欧拉图。</p>
<p><strong>欧拉通路</strong>是经过图中所有边的通路中长度最短的通路。</p>
<p><strong>欧拉回路</strong>是经过图中所有边的回路中长度最短的回路。</p>
<h4 id="判定">判定</h4>
<p>无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>具有一条<strong>欧拉通路</strong>，当且仅当<span
class="math inline">\(G\)</span>是连通的，且仅有零个或两个奇度数结点。</p>
<p>无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>具有一条<strong>欧拉回路</strong>，当且仅当<span
class="math inline">\(G\)</span>是连通的，并且所有结点的度数均为偶数。</p>
<p>有向图<span
class="math inline">\(G\)</span>具有一条<strong>欧拉通路</strong>，当且仅当<span
class="math inline">\(G\)</span>是连通的，且除了两个结点以外，其余结点的入度等于出度，而这两个例外的结点中，一个结点的入度比出度大1，另一个结点的出度比入度大1。</p>
<p>有向图<span
class="math inline">\(G\)</span>具有一条<strong>欧拉回路</strong>，当且仅当<span
class="math inline">\(G\)</span>是连通的，且所有结点的入度等于出度。</p>
<h4 id="一笔画">一笔画</h4>
<p>所谓一笔画是指<strong>笔不离纸</strong>、<strong>不重复</strong>地画出图形。能否一笔画本质上就是求图中是否存在<strong>欧拉通路</strong>（或<strong>欧拉回路</strong>）的问题。</p>
<h4
id="求无向图的欧拉回路fleury算法">求无向图的欧拉回路——Fleury算法</h4>
<p>依次选边，每选一条边就从图中删去。选取条件是：</p>
<ul>
<li>与上一条已选取的边关联；</li>
<li>除非无别的边可选，否则不能选割边（桥）。</li>
</ul>
<p><strong>中国邮路问题</strong></p>
<p>一个邮递员送信，要走完他负责投递的全部街道，完成任务后回到邮局。那么，应该按怎样的路线走，他所走的路程才会最短？</p>
<p><strong>解</strong>  首先转化为图论问题：在一个无向赋权连通图中求一条回路，使其总权值最小。</p>
<p>如果此无向图为欧拉图，则使用Fleury算法直接求欧拉回路即可。</p>
<p>否则，有些边必须重复经过，相当于在原图中添加了一些平行边。从而，只要保证这些平行边的权值最小就行了。</p>
<p><strong>定义</strong>  （中国邮路问题）在一个有奇度数结点的赋权连通图中，增加一些平行边，使得新图不含奇度数结点，并且增加的边的总权值最小。</p>
<p><strong>算法</strong></p>
<p>设<span
class="math inline">\(V_1\)</span>为图中所有奇度数结点的集合。</p>
<ol type="1">
<li>使用Floyd算法计算图中任意两点间的最短通路长度；</li>
<li>构成一个<span class="math inline">\(|V_1 \times
V_1|\)</span>的矩阵，这个矩阵给出了图中每两个奇度数结点间的最短通路长度；</li>
<li>将矩阵中的结点进行两两组合，找出一个最佳的组合情况，这种组合使得它们的最短通路长度之和最小；</li>
<li>根据这个最佳组合，求出各对组合的最短通路，并将最短通路上的每条边都加一条平行边。</li>
</ol>
<h3 id="哈密顿图">11.2 哈密顿图</h3>
<blockquote>
<p><strong>周游世界问题</strong></p>
<p>要求沿正十二面体的边寻找一条路通过20个城市，而每个城市只通过一次，最后返回原地。</p>
</blockquote>
<h4 id="定义-9">定义</h4>
<p>设<span
class="math inline">\(G\)</span>是一个无向或有向图，若存在一条通路（回路），经过图中每个结点一次且仅一次，则称此通路（回路）为该图的一条<strong>哈密顿通路</strong>（回路）。具有哈密顿回路的图称为<strong>哈密顿图</strong>。</p>
<p><strong>规定</strong>  平凡图为哈密顿图。</p>
<p>哈密顿通路是经过图中所有结点的通路中长度最短的通路。</p>
<p>哈密顿回路是经过图中所有结点的回路中长度最短的回路。</p>
<h4 id="必要条件-1">必要条件</h4>
<p><strong>定理</strong>  设无向图<span class="math inline">\(G =
\left&lt;V, E\right&gt;\)</span>是哈密顿图，<span
class="math inline">\(V_1\)</span>是<span
class="math inline">\(V\)</span>的任意非空子集，则<span
class="math inline">\(p(G - V_1) \leq |V_1|\)</span>，其中<span
class="math inline">\(p(G - V_1)\)</span>是从<span
class="math inline">\(G\)</span>中删除<span
class="math inline">\(V_1\)</span>后所得到图的连通分支数。</p>
<p><strong>推论</strong>  设无向图<span class="math inline">\(G =
\left&lt;V, E\right&gt;\)</span>中存在哈密顿通路，则对<span
class="math inline">\(V\)</span>的任意非空子集<span
class="math inline">\(V_1\)</span>，都有<span class="math inline">\(p(G
- V_1) \leq |V_1| + 1\)</span>.</p>
<p>此定理是哈密顿图的<strong>必要条件</strong>，而不是<del>充分条件</del>。</p>
<p>此定理的主要应用是判断某些图不是哈密顿图，即：若存在<span
class="math inline">\(V\)</span>的某个非空子集<span
class="math inline">\(V_1\)</span>使得<span class="math inline">\(p(G -
V_1) &gt; |V_1|\)</span>，则<span
class="math inline">\(G\)</span>不是哈密顿图。</p>
<p>有割点的图一定不是哈密顿图。</p>
<h4 id="充分条件">充分条件</h4>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是具有<span
class="math inline">\(n\)</span>个结点的简单无向图。如果对任意两个不相邻的结点<span
class="math inline">\(u, v \in V\)</span>，均有<span
class="math inline">\(\operatorname{deg}(u) + \operatorname{deg}(v) \geq
n - 1\)</span>，则<span
class="math inline">\(G\)</span>中存在<strong>哈密顿通路</strong>。</p>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是具有<span
class="math inline">\(n\)</span>个结点的简单无向图。如果对任意两个不相邻的结点<span
class="math inline">\(u, v \in V\)</span>，均有<span
class="math inline">\(\operatorname{deg}(u) + \operatorname{deg}(v) \geq
n\)</span>，则<span
class="math inline">\(G\)</span>中存在<strong>哈密顿回路</strong>。</p>
<p><strong>推论</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是具有<span
class="math inline">\(n\)</span>个结点的简单无向图，<span
class="math inline">\(n \geq 3\)</span>。如果对任意<span
class="math inline">\(v \in V\)</span>，均有<span
class="math inline">\(\operatorname{deg}(v) \geq \frac
n2\)</span>，则<span
class="math inline">\(G\)</span>是<strong>哈密顿图</strong>。</p>
<p>定理及其推论给出的是哈密顿图的<strong>充分条件</strong>，而不是<del>必要条件</del>。</p>
<h4 id="tsp问题">TSP问题</h4>
<blockquote>
<p>巡回售货员问题也称为货郎担问题。有一个售货员，从他所在城市出发去访问<span
class="math inline">\(n-1\)</span>个城市，要求经过每个城市恰好一次，然后返回原地。如何安排他的旅行路线才能保证最短？</p>
</blockquote>
<p><strong>问题</strong>  设<span class="math inline">\(G = \left&lt;V,
E, W\right&gt;\)</span>是<span
class="math inline">\(n\)</span>个结点的赋权完全图。这里<span
class="math inline">\(V = \{v_1, v_2, \dots,
v_n\}\)</span>是城市的集合，<span
class="math inline">\(E\)</span>是连接城市的道路集合，<span
class="math inline">\(W\)</span>是从<span
class="math inline">\(E\)</span>到正实数集合的一个函数（即<span
class="math inline">\(W(v_i, v_j)\)</span>是城市<span
class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_j\)</span>之间的距离）。他们之间的距离需满足如下的三角不等式：
<span class="math display">\[
W(v_i, v_j) + W(v_j, v_k) \geq W(v_i, v_k)
\]</span> 试求出该赋权图上的最短哈密顿回路。</p>
<p><strong>解</strong>  找出所有可能的哈密顿回路并计算每条回路的总权值，得到最短通路。</p>
<p>当<span
class="math inline">\(n\)</span>增大时，计算时间不可接受。TSP是NP难问题。</p>
<h3 id="偶图">11.3 偶图</h3>
<h4 id="偶图-1">偶图</h4>
<p>若无向图<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>的结点集<span
class="math inline">\(V\)</span>能够划分为两个子集<span
class="math inline">\(V_1, V_2\)</span>，满足<span
class="math inline">\(V_1 \cap V_2 = \varnothing\)</span>，且<span
class="math inline">\(V_1 \cup V_2 = V\)</span>，使得<span
class="math inline">\(G\)</span>中任意一条边的两个端点，一个属于<span
class="math inline">\(V_1\)</span>，另一个属于<span
class="math inline">\(V_2\)</span>，则称<span
class="math inline">\(G\)</span>为<strong>偶图</strong>或<strong>二分图</strong>或<strong>二部图</strong>。<span
class="math inline">\(V_1\)</span>和<span
class="math inline">\(V_2\)</span>称为互补结点子集，偶图通常记为<span
class="math inline">\(G = \left&lt;V_1, E, V_2\right&gt;\)</span>。</p>
<p><strong>完全偶图</strong></p>
<p>在偶图<span class="math inline">\(G = \left&lt;V_1, E,
V_2\right&gt;\)</span>中，若<span
class="math inline">\(V_1\)</span>中的每个结点与<span
class="math inline">\(V_2\)</span>中的每个结点都有且仅有一条边相关联，则称偶图<span
class="math inline">\(G\)</span>为<strong>完全偶图</strong>或<strong>完全二分图</strong>，记为<span
class="math inline">\(K_{i,j}\)</span>，其中<span
class="math inline">\(i = |V_1|, j = |V_2|\)</span>.</p>
<h4 id="偶图的判定">偶图的判定</h4>
<p><strong>定理</strong>  无向图<span class="math inline">\(G =
\left&lt;V,
E\right&gt;\)</span>为偶图的<strong>充分必要条件</strong>是所有回路的长度均为偶数。</p>
<p>根据偶图的充分必要条件，我们可将平凡图和零图看成特殊的偶图。</p>
<p>常用其逆否命题来判断一个图不是偶图：无向图<span
class="math inline">\(G\)</span>不是偶图的充分必要条件是<span
class="math inline">\(G\)</span>中存在长度为奇数的回路。</p>
<h4 id="偶图的匹配">偶图的匹配</h4>
<p>在偶图<span class="math inline">\(G = \left&lt;V_1, E,
V_2\right&gt;\)</span>中，<span class="math inline">\(V_1 = \{v_1, v_2,
\dots, v_q\}\)</span>，若存在<span
class="math inline">\(E\)</span>的子集<span class="math inline">\(E&#39;
= \{(v_1, v_1&#39;), (v_2, v_2&#39;), \dots, (v_q,
v_q&#39;)\}\)</span>，其中<span class="math inline">\(v_1&#39;,
v_2&#39;, \dots, v_q&#39;\)</span>是<span
class="math inline">\(V_2\)</span>中的<span
class="math inline">\(q\)</span>个不同的结点，则称<span
class="math inline">\(G\)</span>的子图<span class="math inline">\(G&#39;
= \left&lt;V_1, E&#39;, V_2\right&gt;\)</span>为从<span
class="math inline">\(V_1\)</span>到<span
class="math inline">\(V_2\)</span>的一个<strong>完全匹配</strong>，简称<strong>匹配</strong>。</p>
<p>匹配实际上就是在偶图<span class="math inline">\(G = \left&lt;V_1, E,
V_2\right&gt;\)</span>中，寻找<span
class="math inline">\(V_1\)</span>到<span
class="math inline">\(V_2\)</span>的单射。显然，这样的单射有时并不存在。</p>
<p><strong>匹配的判定条件</strong></p>
<p><strong>定理</strong>  （霍尔定理）偶图<span class="math inline">\(G
= \left&lt;V_1, E, V_2\right&gt;\)</span>中存在从<span
class="math inline">\(V_1\)</span>到<span
class="math inline">\(V_2\)</span>的匹配的<strong>充分必要条件</strong>是<span
class="math inline">\(V_1\)</span>中任意<span
class="math inline">\(k\)</span>个结点至少与<span
class="math inline">\(V_2\)</span>中的<span
class="math inline">\(k\)</span>个结点相邻，<span
class="math inline">\(k = 1, 2, \dots,
|V_1|\)</span>。这个条件通常称为<strong>相异性条件</strong>。</p>
<p><strong>定理</strong>  （<span
class="math inline">\(t\)</span>条件）设<span class="math inline">\(G =
\left&lt;V_1, E, V_2\right&gt;\)</span>是一个偶图。如果满足：</p>
<ul>
<li><span class="math inline">\(V_1\)</span>中每个结点至少关联<span
class="math inline">\(t\)</span>条边；</li>
<li><span class="math inline">\(V_2\)</span>中每个结点至多关联<span
class="math inline">\(t\)</span>条边；</li>
</ul>
<p>则<span class="math inline">\(G\)</span>中存在从<span
class="math inline">\(V_1\)</span>到<span
class="math inline">\(V_2\)</span>的匹配。其中<span
class="math inline">\(t\)</span>为正整数。这个条件通常称为<strong><span
class="math inline">\(t\)</span>条件</strong>。</p>
<p><span
class="math inline">\(t\)</span>条件是<strong>充分条件</strong>。不满足<span
class="math inline">\(t\)</span>条件仍可能存在匹配。</p>
<h3 id="平面图">11.4 平面图</h3>
<h4 id="平面图-1">平面图</h4>
<p>如果能够把一个无向图<span
class="math inline">\(G\)</span>的所有结点和边画在平面上，使得任何两边都不会在非结点处交叉，则称<span
class="math inline">\(G\)</span>为<strong>平面图</strong>，否则称<span
class="math inline">\(G\)</span>为<strong>非平面图</strong>。</p>
<blockquote>
<p><strong>例</strong>：平面图</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDGNEq.png" alt="tDGNEq.png" />
<figcaption aria-hidden="true">tDGNEq.png</figcaption>
</figure>
<p><strong>例</strong>：非平面图</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDGB2F.png" alt="tDGB2F.png" />
<figcaption aria-hidden="true">tDGB2F.png</figcaption>
</figure>
</blockquote>
<h4 id="平面图的面">平面图的面</h4>
<p>在平面图<span
class="math inline">\(G\)</span>的一个平面表示中，由边所包围的其内部不包含图的结点和边的区域，称为<span
class="math inline">\(G\)</span>的一个<strong>面</strong>，包围该面的诸边所构成的回路称为这个面的<strong>边界</strong>，面<span
class="math inline">\(r\)</span>的边界的长度称为该面的<strong>次数</strong>，记为<span
class="math inline">\(D(r)\)</span>。区域面积有限的面称为<strong>有限面</strong>，区域面积无限的面称为<strong>无限面</strong>。</p>
<blockquote>
<p><strong>例</strong>：</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDGTrd.png" alt="tDGTrd.png" />
<figcaption aria-hidden="true">tDGTrd.png</figcaption>
</figure>
</blockquote>
<blockquote>
<p>面的概念也可以用下面形象的说法加以描述：</p>
<p>假设我们把一个平面图的平面表示画在平面上，然后用一把小刀，沿着图的边切开，那么平面就被切成许多块，每一块就是图的一个面。更确切地说，平面图的一个面就是平面的一块，它用边作边界线，且不能再分成子块。</p>
<p>另外，对于同一平面图的不同平面表示（例如下图中，将<span
class="math inline">\(h\)</span>放在里面），虽然面的数目相同，但写出的边界和对应的次数可以不同。</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDN3iq.png" alt="tDN3iq.png" />
<figcaption aria-hidden="true">tDN3iq.png</figcaption>
</figure>
</blockquote>
<p><strong>定理</strong>  平面图的所有面的次数之和等于边数的二倍。</p>
<h4 id="欧拉公式">欧拉公式</h4>
<blockquote>
<p>1750年，欧拉发现，任何一个凸多面体，若有<span
class="math inline">\(n\)</span>个顶点、<span
class="math inline">\(m\)</span>条棱和<span
class="math inline">\(r\)</span>个面，则有<span class="math inline">\(n
- m + r =
2\)</span>.这个公式可以推广到平面图上来（球极投影），称之为<strong>欧拉公式</strong>。</p>
</blockquote>
<p><strong>定理</strong>  设<span class="math inline">\(G = \left&lt;V,
E\right&gt;\)</span>是连通平面图，若它有<span
class="math inline">\(n\)</span>个结点、<span
class="math inline">\(m\)</span>条边和<span
class="math inline">\(r\)</span>个面，则有 <span class="math display">\[
n - m + r = 2
\]</span></p>
<h4 id="平面图的必要条件">平面图的必要条件</h4>
<p><strong>推论</strong>  设<span
class="math inline">\(G\)</span>是一个<span class="math inline">\((n,
m)\)</span>简单连通平面图，若<span class="math inline">\(m &gt;
1\)</span>，则有 <span class="math display">\[
m \leq 3n - 6
\]</span></p>
<blockquote>
<p>该推论是<strong>必要条件</strong>。即，一个简单连通图，若不满足<span
class="math inline">\(m \leq 3n - 6\)</span>，则一定是非平面图。</p>
</blockquote>
<p><strong>推论</strong>  设<span
class="math inline">\(G\)</span>是一个<span class="math inline">\((n,
m)\)</span>简单连通平面图，若每个面的次数至少为<span
class="math inline">\(k(k \geq 3)\)</span>，则有 <span
class="math display">\[
m \leq \frac{k}{k-2}(n-2)
\]</span></p>
<blockquote>
<p>该推论是<strong>必要条件</strong>。即，一个简单连通图，若每个面的次数至少为<span
class="math inline">\(k(k \geq 3)\)</span>，若不满足<span
class="math inline">\(m \leq
\frac{k}{k-2}(n-2)\)</span>，则一定是非平面图。</p>
</blockquote>
<h4 id="库拉托夫斯基定理">库拉托夫斯基定理</h4>
<p><strong>同胚</strong></p>
<p>如果两个图<span class="math inline">\(G_1\)</span>和<span
class="math inline">\(G_2\)</span>同构，或经过反复插入或消去2度结点后同构，则称<span
class="math inline">\(G_1\)</span>与<span
class="math inline">\(G_2\)</span><strong>同胚</strong>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDYSfK.png" alt="tDYSfK.png" />
<figcaption aria-hidden="true">tDYSfK.png</figcaption>
</figure>
<p><strong>收缩</strong></p>
<p>图中边<span class="math inline">\(e = (u,
v)\)</span>的<strong>收缩</strong>是指从<span
class="math inline">\(G\)</span>中删除<span
class="math inline">\(e\)</span>，将<span
class="math inline">\(e\)</span>的两个端点<span class="math inline">\(u,
v\)</span>重合，用一个新的结点<span
class="math inline">\(w\)</span>代替，使<span
class="math inline">\(w\)</span>关联除<span
class="math inline">\(e\)</span>外的<span
class="math inline">\(u\)</span>和<span
class="math inline">\(v\)</span>关联的一切边，称为边<span
class="math inline">\(e\)</span>的收缩。一个图可以收缩为图<span
class="math inline">\(H\)</span>，是指<span
class="math inline">\(H\)</span>可以从<span
class="math inline">\(G\)</span>经过若干次边的收缩而得到。</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDYkmd.png" alt="tDYkmd.png" />
<figcaption aria-hidden="true">tDYkmd.png</figcaption>
</figure>
<p><strong>库拉托夫斯基定理</strong></p>
<p><strong>定理</strong>  一个图是平面图的充分必要条件是它的任何子图都不与<span
class="math inline">\(K_5\)</span>或<span class="math inline">\(K_{3,
3}\)</span>同胚。</p>
<p><strong>定理</strong>  一个图是平面图的充分必要条件是它的任何子图都不能收缩为<span
class="math inline">\(K_5\)</span>或<span class="math inline">\(K_{3,
3}\)</span>。</p>
<figure>
<img src="https://s1.ax1x.com/2020/06/05/tDY30s.png" alt="tDY30s.png" />
<figcaption aria-hidden="true">tDY30s.png</figcaption>
</figure>
<h2 id="复习要点">复习要点</h2>
<blockquote>
<p>凡<em>〔扩展内容〕</em>一概不考。</p>
</blockquote>
<h3 id="集合">集合</h3>
<ul>
<li>可数集合、不可数集合</li>
<li>包含</li>
<li>集合的定义</li>
</ul>
<h3 id="数理逻辑">数理逻辑</h3>
<ul>
<li>自由变元、约束变元</li>
<li>推理规则（US等等）</li>
<li><strong>主析取、合取范式</strong>（必考）</li>
<li><strong>谓词逻辑推理</strong>（必考）
<ul>
<li>前置：命题逻辑推理</li>
<li>命题符号化</li>
<li>演绎法：后面的<span class="math inline">\(I,
T\)</span>等标注必须正确</li>
</ul></li>
<li>公式类型：重言式、可满足式、矛盾式等</li>
<li>基本等价关系</li>
</ul>
<h3 id="关系理论">关系理论</h3>
<ul>
<li>二元关系
<ul>
<li>基本运算：复合运算、逆运算</li>
<li>性质：自反、传递等；保守性</li>
<li><del><em>闭包不考</em></del></li>
</ul></li>
<li><strong>特殊关系</strong>（常考）
<ul>
<li>等价</li>
<li>次序：拟序、良序、<strong>偏序</strong>（必考）等</li>
</ul></li>
<li>函数
<ul>
<li><del><em>置换函数不考</em></del></li>
</ul></li>
<li>概念
<ul>
<li>复合运算</li>
<li>性质</li>
</ul></li>
</ul>
<h3 id="图论">图论</h3>
<ul>
<li>图
<ul>
<li>最短通路（掌握 <strong>Dijkstra</strong> 和 Floyd 其一即可）</li>
<li><del><em>中国邮递员等两个问题不考</em></del></li>
</ul></li>
<li>树
<ul>
<li>最小生成树（掌握其一即可）</li>
</ul></li>
<li>特殊图
<ul>
<li>平面图：<del><em>对偶、着色不考</em></del></li>
<li>欧拉图等图的概念</li>
<li>偶图、子图、完全图、补图等的概念（能判定）
<ul>
<li>偶图：能判定其匹配</li>
</ul></li>
</ul></li>
</ul>
<p>〔离散数学 完〕</p>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2020/08/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%20-%20%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">离散数学 - 课堂笔记</a></li>
                
                
                    <li>下一篇: <a href="/2020/06/23/%E6%B2%A1%E5%86%99%E5%AE%8C%E7%9A%84%E8%BD%BB%E5%B0%8F%E8%AF%B42/">【没写完的轻小说之二】废土生存手册</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a><a class="-none-link" href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" rel="tag">课堂笔记</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="/images/favicon.png" alt="GreatSeal" />
            </figure>
        
            <div class="author-info">
                <h4>GreatSeal</h4>
                <p>来自佛得角的大海豹。</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/07/14/quine/">Quine 程序：打印自己的源代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/09/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/09/Hello%20World!/">Hello World!</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/01/%E8%AF%97%E6%AD%8C/">诗歌</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%20-%20%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">离散数学 - 课堂笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学 - 课堂笔记</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 20px;">小说</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/%E6%9E%81%E5%AE%A2/" style="font-size: 10px;">极客</a> <a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 10px;">诗歌</a> <a href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">课堂笔记</a> <a href="/tags/%E9%95%BF%E7%AF%87/" style="font-size: 15px;">长篇</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2022 <a href="/">佛得角大海豹的博客</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
